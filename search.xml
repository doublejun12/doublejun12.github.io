<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Max-E3SAT问题的不可近似性：从Cook-Levin到Håstad&#39;s E3-SAT Hardness</title>
      <link href="/2020/12/11/max-3sat/"/>
      <url>/2020/12/11/max-3sat/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>​        这学期花费了一段时间看了一遍Venkatesan Guruswami和Ryan O’Donnell两位大神关于PCP定理和不可近似性的lecture notes。<strong>PCP</strong>定理本身不必多说，后面关于不可近似性的内容也属实精彩。一直想写点东西把这方面的知识从头到尾总结一下，于是就诞生了这篇文章。本文预计从1971年Stephen Cook证明<strong>3SAT</strong>是$\mathcal{NP}$完全问题开始说起，一直到2001年Håstad证明7/8是<strong>Max-3SAT</strong>问题的最优近似比结束，把这30年的研究历史简要概括一下，不涉及到一些证明的细节，我感兴趣的部分可能会展开详细说一下。由于本人水平实在不行，有任何写得不对的地方或者有问题的地方欢迎大家指出。</p><p>​        关于<strong>SAT</strong>问题，相信每个对计算理论有点了解的同学都不陌生，<strong>SAT</strong>问题说的是输入一个布尔表达式，问是否存在一种赋值方案，使得该布尔表达式被满足（结果为1）. 所谓的<strong>3SAT</strong>问题，指的就是该布尔表达式是一个合取范式(CNF)，该CNF中每个子句(clause)的变量个数不超过3个。如果每个子句变量的个数都恰好为3个的话，那么该问题称为<strong>E3SAT</strong>问题，一个<strong>E3SAT</strong>问题的实例(instance)如下：</p><script type="math/tex; mode=display">F=(x_1 \lor \overline{x_2} \lor x_5) \land (\overline{x_1} \lor \overline{x_3} \lor x_4) \land (\overline{x_2} \lor x_3 \lor x_5)</script><p>在上述实例中，对变量赋值$x=(1,0,0,1,1)$就能使得上述表达式的值为1，也就是说该表达式是能被满足的。那么我们能否设计一个高效（多项式时间）的算法来判定<strong>E3SAT</strong>问题呢？</p><p>​        上述所说的几种<strong>SAT</strong>问题，指的都是判定问题（Decision Problem），也就是说这些问题的输出为$1$或者$0$，如果输入的表达式能满足的话就输出$1$，反之输出$0$。在理论计算机领域中，通常我们把一个判定问题结果为1的所有输入构成的集合称为是一个语言$\mathcal{L}$。比如<strong>E3SAT</strong>问题对应的语言就是所有能被满足的<strong>3CNF</strong>表达式构成的集合。如果要求把最优赋值方案找出来，使得它能满足最多的子句，那这种问题称为搜索问题（Search Problem）记为<strong>Max-E3SAT</strong>。显然搜索问题不会比判定问题简单。</p><p>​        顺便一提，如果<strong>3SAT</strong>问题能在多项式时间内判定，并且输入的<strong>3CNF</strong>表达式能被满足的话，那该表达式的赋值方案也能在多项式时间内求解出来。假设存在多项式时间的算法D能判定<strong>3SAT</strong>问题，我们可以构造一个新的多项式时间的算法S找出能满足的赋值方案。比如输入的<strong>3SAT</strong>问题实例是$F$，有$n$个变量，先调用一次D，如果D返回能满足，我就先把$x_1$赋值为0，然后把得到的$F_1$再次提交给D，如果D返回能满足，我接下来就把$x_2$进行赋值……如果D返回不能满足的话，那我就明白把$x_1$赋值为1是一定能满足的，接着把赋值后的表达式再次提交给D。如此反复，也就是说我只要重复调用D $n$次就能把该赋值找出来。</p><h1 id="2-一切的起始：Cook-Levin定理"><a href="#2-一切的起始：Cook-Levin定理" class="headerlink" title="2. 一切的起始：Cook-Levin定理"></a>2. 一切的起始：Cook-Levin定理</h1><h2 id="2-1-Cook-Levin定理概述"><a href="#2-1-Cook-Levin定理概述" class="headerlink" title="2.1 Cook-Levin定理概述"></a>2.1 Cook-Levin定理概述</h2><p>​        很遗憾，Stephen Cook告诉我们，<strong>SAT</strong>问题是不存在多项式时间的算法的，除非$\mathcal{P}=\mathcal{NP}$。1971年Cook大神在读博期间发表了一篇名为 “The Complexity of Theorem Proving Procedures”的文章，该文章形式化地定义了复杂性领域中的两个基本概念“多项式时间规约（Polynomial-time Reduction）”和“$\mathcal{NP}$完全（$\mathcal{NP}$-Completeness）”。规约，指的就是把一个问题实例转化成另一个问题的实例，并保持实例的一些属性。比如从图的3着色问题规约到SAT问题，输入一个图，经过规约算法后输出一个布尔表达式，该布尔表达式可满足当且仅当输入的图是可以进行3着色的。所谓的$\mathcal{P}$问题，指的就是能在多项式时间求解的问题。$\mathcal{NP}$问题，指的是能在多项式时间内被验证的问题，$\mathcal{NP}$问题的解也称为witness。$\mathcal{NP}$完全问题指在$\mathcal{NP}$中难度最大的问题，更严谨来说，$\mathcal{NP}$完全问题是一种特殊的$\mathcal{NP}$问题，其他所有的$\mathcal{NP}$问题都能在多项式时间内规约到它。Cook也在该篇文章中证明了第一个$\mathcal{NP}$完全问题：<strong>SAT</strong>。1982年，Cook因为该项工作获得图灵奖。</p><p><strong>定理 2.1[Cook71]”Cook-Levin定理”：</strong> <strong>SAT</strong>是$\mathcal{NP}$完全的。</p><p><strong>SAT</strong>问题可以简单地规约到<strong>E3SAT</strong>问题上来，所以<strong>E3SAT</strong>问题也是$\mathcal{NP}$完全的。</p><p>​        这篇文章也留下了计算机科学领域最著名的问题：$\mathcal{P}=\mathcal{NP}$？也就是说多项式时间内能验证的问题是否一定能在多项式时间内求解？通过$\mathcal{NP}$完全的定义我们可以意识到，如果$\mathcal{NP}$完全问题能在多项式时间内求解的话，那么所有$\mathcal{NP}$问题都将能在多项式时间内求解。所以如果<strong>E3SAT</strong>能在多项式时间内求解的话，那么所有$\mathcal{NP}$问题（像什么图的3着色啊，哈密顿回路啊等等）都能在多项式时间内求解。一般人都认为$\mathcal{P}$和$\mathcal{NP}$是不太可能相等的（某些怪人除外），所以为<strong>E3SAT</strong>问题寻找多项式时间的算法大部分人认为是不可行的。既然判定<strong>E3SAT</strong>问题是一个难问题，那为<strong>E3SAT</strong>的实例找出一种最优的赋值方案当然是更难的问题。</p><h2 id="2-2-我们能否找到近似解？"><a href="#2-2-我们能否找到近似解？" class="headerlink" title="2.2 我们能否找到近似解？"></a>2.2 我们能否找到近似解？</h2><p>​        既然无法设计一个多项式时间的算法判定<strong>E3SAT</strong>问题，那我们能不能设计一个有效的算法找出一种赋值方案使得它尽可能满足多的子句呢？很简单，只要对每个变量进行随机赋值即可！那大家思考一下，这样的赋值方案从期望来说能让多少个子句被满足呢？没错！只要进行这样的一种平凡赋值就能让$7/8$的子句获得满足。这是因为在随机赋值的情况下每个子句被满足的概率为$7/8$，假设该表达式中有$m$个句子，那根据Linearity of Expectation，期望上有$7/8\cdot m$的子句能被满足。通过Derandomization的方法可以将该算法转化成确定性算法，输出一种赋值方案满足$7/8$以上的子句。事实上，对于普通的<strong>3SAT</strong>问题，如果把某个实例中最多能被满足的子句数量记为$OPT$的话，我们也可以在多项式时间内找出一种赋值方案使得它能满足$7/8\cdot OPT$的子句[Karloff97]。</p><p>​        Cook-Levin定理告诉我们，找出<strong>Max-E3SAT</strong>问题的最优赋值方案（$100\%$）是困难的，通过上面的分析我们明白找到一个$7/8$的近似解是简单的（即$7/8$近似算法）。那么我们能否能找到效果更好的算法呢？比如$8/9, 9/10,…$ ？多项式时间算法能达到的最优的近似比是多少？从Cook-Levin定理提出的30年之后，该问题才得到了回答。</p><h1 id="3-“懒人”的证明系统：PCP定理"><a href="#3-“懒人”的证明系统：PCP定理" class="headerlink" title="3. “懒人”的证明系统：PCP定理"></a>3. “懒人”的证明系统：PCP定理</h1><h2 id="3-1-交互式证明系统"><a href="#3-1-交互式证明系统" class="headerlink" title="3.1 交互式证明系统"></a>3.1 交互式证明系统</h2><p>​        我们先抛开上述<strong>Max-E3SAT</strong>问题，把目光移向密码学界。1985年，Cook-Levin定理被证明后过了14年，密码学领域出现了一篇很有趣的论文”The Knowledge Complexity of Interactive Proof Systems”。作者为Goldwasser, Micali, 以及Rackoff[GMR85]。这篇论文的工作对密码学领域与计算复杂性领域产生了非常重大的影响，Goldwasser, Micali也由于该项工作（还有一些其他密码学上的贡献）获得了2012年图灵奖。有趣的是，这篇文章投稿过FOCS’83，STOC‘84，FOCS’84，但都被拒绝了，一直到STOC‘85才被接收。这篇文章定义了两个新的概念，称为交互式证明系统（Interactive Proof Systems）与零知识证明（Zero-Knowledge Proof Systems）。关于零知识证明方面，相信了解区块链的同学一定不陌生。这是一种非常神奇的证明系统，比如我想向你证明某个命题的准确性，我能在不泄露额外秘密的情况下让你相信一个命题的真假性。本文不会讲零知识证明方面的内容，有兴趣的同学可以看看Bar-Ilan University的<a href="https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/" target="_blank" rel="noopener">零知识证明课程</a>。</p><p>​        那么什么是交互式证明系统呢？证明系统指的其实就是一个计算能力无限的证明者（Prover）与概率多项式时间的验证者（Verifier）双方的一个游戏，验证者借助证明者帮她判断某个命题的真假。我们首先回顾一下关于$\mathcal{NP}$的定义，$\mathcal{NP}$问题说的是在多项式时间内能判定的问题，那其实对于任何一个$\mathcal{NP}$问题都可以建立一个平凡的一轮证明系统——对于<strong>3SAT</strong>问题，证明者只要把最优的赋值方案发送给验证者即可，验证者可以自己验证该表达式能不能被满足。交互式证明系统指的是证明者验证者双方可以进行多轮的交互，并且验证者有coin-tossing的能力（也就是随机算法）。把所有能建立交互式证明的语言构成的集合称为$\mathcal{IP}$，$\mathcal{NP}$就是$\mathcal{IP}$的一个平凡子集。那么$\mathcal{IP}$包含$\mathcal{NP}$外的其他语言吗？事实上1990年Shamir证明了$\mathcal{IP}=\mathcal{PSPACE}$，也就是说任何多项式空间能判定的问题都可以建立一个交互式证明系统。</p><p>​        1988年，Michael Ben-Or, Goldwasser, Joe Kilian, 和Wigderson为了移除零知识证明中的某些密码学假设，提出了多证明者的交互式证明系统[BGKW88]。在这种证明系统中，证明者可以有多个并且相互之间不能进行通信。作者证明了多个证明者（多项式多个证明者）和两个证明者是等价的。把所有能建立此类证明系统的语言记为$\mathcal{MIP}$， Babai, Fortnow, and Lund证明了$\mathcal{MIP}=\mathcal{NEXP}$，也就是所有能在指数时间内验证的问题都可以设计一个多证明者的交互式证明系统。从直觉上考虑，两个证明者之间不能进行通信，所以证明者进行欺骗的概率就大大降低了，也就是说双证明者的证明复杂性要小于单证明者（验证者提问的次数减小了），这个直觉直接促使了后续PCP理论的诞生与发展（这篇文章的工作也促使了Derandomization领域的诞生与发展）。Fortnow，Rompel，Sisper证明了$\mathcal{MIP}$与一种叫Oracle Proof System的系统是等价的[FRS88]。</p><p><strong>引理3.1[FRS88]：</strong> 令$\mathcal{L}$是一个语言，$M$是概率多项式时间的oracle图灵机使得</p><ul><li>$x \in L \Rightarrow $ 存在一个Oracle $\mathcal{O}$使得$M^{\mathcal{O}}$以大于$c$的概率接受$x$。</li><li>$x \notin L \Rightarrow $ 对于任意的Oracle $\mathcal{O}$，$M^{\mathcal{O}}$以小于$s$的概率接受$x$。</li></ul><p>则语言$\mathcal{L}$存在一个双证明者的交互式证明协议。（$\mathcal{L} \in \mathcal{MIP}$）</p><p>Oracle 可以理解为$\mathcal{O}$是$M$的黑盒子程序，$M$可以不断地对$\mathcal{O}$进行提问，获得相应的回答。事实上，这个Oracle Proof System其实就是下文要说明的一个重要概念：概率可验证证明<strong>PCPs</strong>（Probabilistic Checkable Proofs）</p><h2 id="3-2-概率可验证证明"><a href="#3-2-概率可验证证明" class="headerlink" title="3.2 概率可验证证明"></a>3.2 概率可验证证明</h2><p>​        上文所提到的Oracle Proof System，其实可以理解为这么一回事，把这个Oracle $\mathcal{O}$看成是证明者提供的一段证明。证明者把关于某个命题的证明$\pi$写下来之后，验证者可以随机选择该证明中的几个位置来判断该命题是否是正确的，这其实就是概率可验证证明<strong>PCPs</strong>。</p><p><strong>定义3.2：</strong>令$\mathcal{L}$是一个语言，$M$是概率多项式时间的图灵机使得</p><ul><li>$x \in L \Rightarrow $ 存在证明 $\pi$ 明使得$M^{\pi}$以大于$c$的概率接受$x$。（$c$也成为该证明系统的完备性Completeness）</li><li>$x \notin L \Rightarrow $ 对于任意的证明 $\pi$，$M^{\pi}$以小于$s$的概率接受$x$。（$s$也成为该证明系统的稳健性Soundness）</li></ul><p>则称语言$\mathcal{L}$存在概率可验证证明，若$M$使用了$O(r(n))$个随机比特，查询了证明中的$O(q(n))$个位置，并且证明中的所有字符都是字母表$\Sigma$中的元素，则称$\mathcal{L} \in \mathcal{PCP}_{c,s}[r(n), q(n)]_{\Sigma}$. </p><p>​        一个显然的结论是 $\mathcal{NP} \subseteq \mathcal{PCP}_{1,0}[0,poly(n)]_{\{0,1\}}$，这是由于$\mathcal{NP}$的定义，PCP证明者直接把witness当成是一段证明，验证者把整段证明读取下来后在确定性多项式时间内进行验证就行了。如果允许验证者进行coin-tossing，那么我们能否降低查询复杂性？答案是YES！其实并不需要把整段证明都读取下来，只要证明者对witness以一种特殊的方式进行编码，我们可以只查询常数个位置就能判断某个命题的真假。这就是计算复杂性理论中大名鼎鼎的PCP定理。</p><p><strong>定理3.3[ALMSS92]”PCP Theorem”：</strong>$\mathcal{NP} \subseteq \mathcal{PCP}_{1,1/2}[\log n,1]_{\{0,1\}}$.</p><p>​        比如某人告诉你他证明了黎曼猜想，并且把证明发送给了你，但你是个非常懒惰的人，根本没有时间阅读这整段证明。PCP定理告诉我们，若把这段证明进行特殊编码，你只需要使用 $\log n$ 个随机比特，然后查询证明中的常数个位置的比特，你就可以以较大的概率判断这段证明的真假性！“懒人”也可以当一个好“评委”！</p><p>​        Arora，Lund，Motwani，Sudan，Szegedy等人在1992年首先证明了PCP定理，但是证明过程非常昂长，完整版论文长达150多页。后人有对这一版的证明进行过整理，证明思路还是非常清晰的。首先使用Hadmard码与Linearity Testing的技术构造指数证明长度的PCP（$\mathcal{NP} \subseteq \mathcal{PCP}_{1,1/2}[poly(n),1]_{\{0,1\}}$，该结论的证明较为简单，一般Graduate Complexity课程都会涉及，我个人也是在看这个证明的过程中开始对PCP感兴趣的），其次使用Low-Dgree Extension的方法与Low-Degree Testing再加上Sumcheck Protocol构造多项式规模的PCP（$\mathcal{NP} \subseteq \mathcal{PCP}_{1,1/2}[\log(n),polylog(n)]_{\{0,1\}}$），然后使用上述两个PCP构造Robust PCP与PCP of Proximity，最后用Proof Composition的方法对上述的PCP进行整合得到最终的PCP定理（也许后面我会写点这方面的博客）。完整的证明过程推荐Alessandro Chiesa的课程 <a href="http://people.eecs.berkeley.edu/~alexch/classes/CS294-S2019.html" target="_blank" rel="noopener">Probabilistically Checkable and Interactive Proof Systems</a>，这位大佬用了12节课完成了PCP定理的证明。2005年，Irit Dinur用了图论和组合的方式重新证明了PCP定理，把证明的过程缩减到了30页左右。关于Irit Dinur的证明过程，推荐Venkatesan Guruswami和Ryan O’Donnell的lecture notes <a href="https://courses.cs.washington.edu/courses/cse533/05au/" target="_blank" rel="noopener">The PCP Theorem and Hardness of Approximation</a> ，这也是本文的主要参考文献。这两版的证明分别于2001年与2019年获得哥德尔奖。</p><h2 id="3-3-Gap问题与不可近似性"><a href="#3-3-Gap问题与不可近似性" class="headerlink" title="3.3 Gap问题与不可近似性"></a>3.3 Gap问题与不可近似性</h2><p>​        上面介绍了一堆和证明系统相关的东西，和本文的主题“不可近似性”有什么关系呢？在回答这个问题之前，我们先来回忆一下<strong>E3SAT</strong>问题的定义，<strong>E3SAT</strong>问题说的是输入一个有$m$个子句的表达式，若所有子句都能被满足则输出YES，若至少有一个子句不能被满足则输出NO。我们可以把这两种情况进行一般化，定义$GAP-E3SAT_{c,s}$问题。</p><p><strong>定义3.4”$GAP-E3SAT_{c,s}(0&lt;s \leq c \leq 1)$”：</strong>给定一个有$m$个子句的E3SAT表达式，</p><ul><li>若$OPT \geq cm$，则输出YES。</li><li>若$OPT &lt; sm$，则输出NO。</li><li>若$sm \leq OPT &lt; cm$，则可任意输出。</li></ul><p>$c-s$也称为该问题的gap。当 $c=1, s=1-1/m$时，这就是正常的<strong>E3SAT</strong>问题（gap为$1/m$），是NP-hard的。注意到如果上述GAP问题是NP-hard的话，那对于<strong>MAX-E3SAT</strong>来说就不存在$(s/c)$-近似算法了。假设MAX-3SAT存在$(s/c)$-近似算法$A$，如果输入的<strong>3SAT</strong>表达式 $\psi$ 满足 $OPT \geq cm$，则 $A(\psi) \geq (s/c)\cdot OPT \geq (s/c)\cdot cm = sm$。如果输入的<strong>3SAT</strong>表达式 $\psi$ 满足 $OPT &lt; sm$，则 $A(\psi) &lt; OPT \leq sm$。所以该多项式时间的算法能对GAP问题中的两种情况进行区分，与该问题是NP-hard是相矛盾的。</p><p>​        令人震惊的是，上述GAP问题的NP-hard性与PCP定理是等价的！！PCP定理也可以表述为：</p><p><strong>定理3.5”PCP Theorem”：</strong> 存在一个常数$s$，使得$GAP-E3SAT_{1,s}$ 是NP-hard的。</p><p>​        从表面上看，定理3.3与定理3.5是两个完全不同的定理，定理3.3说的是一个证明系统，定理3.5是一个问题的难解性。接下来，我们将花点篇幅证明定理3.3与3.5的等价性。</p><p><strong>定理3.3与定理3.5的等价性证明：</strong></p><p><strong>从定理3.5推出定理3.3：</strong>假设$GAP-E3SAT_{1,s}$是$\mathcal{NP}$难的，构造该问题的PCP系统。给定一个3SAT表达式$\psi$包含$n$个子句。证明者将提供$\psi$的赋值。$V$使用$\log $个随机比特n选择一个随机的子句$\phi$，查询该子句中变量的赋值，验证该子句是否能被满足。注意到此时需要查询的比特数量为3。该PCP系统满足下列属性：</p><ul><li>完备性：若$OPT=n$，则证明者只要提供能满足的赋值即可，验证者接受的概率为1.</li><li>稳健性：若$OPT&lt;sn$，则不管证明者怎么进行赋值，能满足的表达式最多有$sn$个，验证者选择到的概率不超过$s$，也就是说验证者验证接受的概率小于$s$。通过独立并行重复检查$O(1)$个字句后能把概率降低到$1/2$以下。</li></ul><p><strong>从定理3.5推出定理3.3：</strong>假设$\mathcal{NP} \subseteq \mathcal{PCP}_{1,1/2}[\log n,1]_{\{0,1\}}$，令$\mathcal{L} \in \mathcal{PCP}_{1,1/2}[\log n,1]_{\{0,1\}}$是某个$\mathcal{NP}$完全语言，$V$是该证明系统的验证者。下面构造从语言$\mathcal{L}$到$GAP-E3SAT_{1,s}$的多项式时间规约$R$。$R$枚举验证者$V$所有可能的随机选择，一共有$2^{O(\log n)} = poly(n)=N$种可能。每一次的随机选择都指定了该证明中的$q$个位置$\{x_{i1},x_{i2},…,x_{iq}\}$，以及关于这$q$个位置的断言$\phi$（当验证者输入这些值后的输出）。$R$将布尔表达式$\phi(x_{i1},x_{i2},…,x_{iq})$转化成对应的$3CNF$表达式（可能需要加上某些辅助变量），并且该布尔表达式中子句的个数为$K=q\cdot 2^{q}$。最终$R$输出包含$m=N\cdot K$个子句的$3CNF$表达式。显然$R$是多项式时间的算法，下面证明$R$是正确的规约：</p><ul><li><p>完备性：若$x\in \mathcal{L}$，则存在证明使得不管验证者采取何种随机值，验证者输出都为1，也就是说$3CNF$表达式中每个子句都能被满足，$OPT=m$。</p></li><li><p>稳健性：若$x\notin L$ ，则对于任意的证明，验证者的所有$N$次验证中至少有一半无法验证通过。则每个验证对应的$3CNF$表达式中至少有一个子句是不能被满足的，能被满足的子句最多为$K-1=K(1-1/K)$个。所以，一共能被满足的子句不会超过</p><p><script type="math/tex">\frac{N}{2} K(1-1 / K)+\frac{N}{2} K=N K\left(1-\frac{1}{2 K}\right)=m\left(1-\frac{1}{2 K}\right)</script>。</p><p>令$s=(1-\frac{1}{2 K})$为一个小于1的常数，则$OPT \leq sm$。</p></li></ul><p>所以$GAP-E3SAT_{1,s}$是$NP-hard$的。最终我们得出结论定理3.3与定理3.5等价。</p><p>​        这个$s$是非常接近1得一个常数，大约等于$0.999999$。也就是说通过PCP定理能得出$GAP-E3SAT_{1,0.999999}$ 是NP-hard的。通过上面的分析我们明白了<strong>MAX-E3SAT</strong>问题不存在近似比为$0.999999$的近似算法。我们终于从Cook-Levin定理往前跨进了一小步，不仅仅求得$100\%$的最优解是难的，求得$99.9999\%$的最优解也是难的。这$0.0001\%$的推进花费了20年的时间！PCP定理也成为了证明Hardness of Approximation的关键技术，一系列的组合优化问题都能通过PCP定理获得相应不可近似性的结论，见Luca Trevisan的<a href="https://arxiv.org/abs/cs/0409043" target="_blank" rel="noopener">survey</a>。</p><h1 id="4-Parallel-Repetition定理：当博弈论进入计算复杂性"><a href="#4-Parallel-Repetition定理：当博弈论进入计算复杂性" class="headerlink" title="4. Parallel Repetition定理：当博弈论进入计算复杂性"></a>4. Parallel Repetition定理：当博弈论进入计算复杂性</h1><h2 id="4-1-Label-Cover问题"><a href="#4-1-Label-Cover问题" class="headerlink" title="4.1 Label Cover问题"></a>4.1 Label Cover问题</h2><p>​        到此，我们还没有回答本文最重要的问题：对于<strong>Max-E3SAT</strong>问题，多项式时间的算法能达到的最优近似比是多少？通过2，3两节的分析，我们知道这个最优的近似比肯定大于等于$7/8$，小于$0.999999$。事实上我们到回答这个问题还有一段距离！在此之前，我们先来看一个在不可近似领域中最核心的问题：Label Cover Problem。</p><p><strong>定义4.1：</strong>字母表$\Sigma$上的Label Cover问题由一个二分无向图$G=(V_1,V_2,E)$与一个约束集$\mathcal{C}$来定义。并满足下面几个条件：</p><ul><li>该图的左半部分是正则的，也就是说$V_1$中每个顶点度数相等。</li><li>约束集$\mathcal{C}$中的每个元素指定了图$G$中对应边上的约束。若$e\in E$，则对应的约束记为$c_e\in \mathcal{C}$，其中$c_e \subseteq \Sigma \times \Sigma$。</li><li>约束集中的所有约束拥有“投影特性”：考虑约束$c_{(u,v)} \in \mathcal{C}$，对于顶点$u \in V_1$的任何一种赋值$a\in\Sigma$，顶点$v\in V_2$的赋值是唯一确定的（也就是说当$u$的赋值确定好后，$v$的赋值也就确定了）。此时我们可以把约束看成是一个函数$\Pi_{(u,v)}: \Sigma \rightarrow \Sigma$。</li></ul><p>给定一个字母表$\Sigma$，<strong>MAX-LC($\Sigma$)</strong> 问的就是找出一种最优赋值方案，使得能满足约束的边达到最多。对应的GAP问题记为<strong>$GAP-LC(\Sigma)_{1, \epsilon}$</strong> 。</p><p>与3.3小节的证明类似，我们可以通过PCP定理证明下述Label Cover问题的不可近似性。</p><p><strong>引理4.2：</strong>存在一个常数$s$与一个常数大小的字母表$\Sigma_0$，使得<strong>$GAP-LC(\Sigma_0)_{1, s}$</strong>是NP-hard的。</p><p>​        我们能自然想到的一个问题是，能否将$s$进一步缩小？（换句话说，将gap放大）如果$s$能进一步缩小的话，那就能得到更好的关于不可近似性结果了。将$s$缩小最容易想到的方法并行运行PCP验证者多次，但此时会增加查询复杂性，或者增大字母表的大小。为了分析该PCP证明系统的相关参数，我们引入一个与二分Label Cover问题等价的概念“双证明者的一轮博弈（2 Prover 1 Round Game）”。（回忆3.1节我们说过PCP证明系统与多证明者证明系统的关系）</p><h2 id="4-2-双证明者的一轮博弈（2P1R-Game）"><a href="#4-2-双证明者的一轮博弈（2P1R-Game）" class="headerlink" title="4.2 双证明者的一轮博弈（2P1R Game）"></a>4.2 双证明者的一轮博弈（2P1R Game）</h2><p><strong>定义4.3”双证明者的一轮博弈（2P1R Game）”：</strong>双证明者的一轮博弈（2P1R Game）由两个证明者（或者称两个玩家）$P_1,P_2$与一个验证者$V$所进行，并有以下参数：</p><ul><li>$P_1$的问题集合$X$。</li><li>$P_2$的问题集合$Y$。</li><li>回答集合$A$。</li><li>$X\times Y$上的概率分布$\lambda$。</li><li>$V$在集合$X\times Y \times A \times A$上的断言（接受或者拒绝）。</li><li>$P_1$采取的策略$f_1: X \rightarrow A$，$P_2$采取的策略$f_2: Y \rightarrow A$。</li></ul><p>该博弈过程如下进行：</p><ul><li>验证者根据概率分布$\lambda$随机选择$(x,y) \in X \times Y$，将$x$发送给$P_1$，$y$发送给$P_2$。</li><li>$P_1$回答$a=f_1(x)$，$P_2$回答$b=f_2(y)$。</li><li>$V$验证$x,y,a,b$上的断言$V(x,y,a,b)$；若该断言能被满足则称证明者$P_1,P_2$胜利。</li></ul><p>给定一个2P1R Game $G$，定义$\omega(G)$为当证明者使用最佳策略时，其获胜的概率。（也就是说是证明者获胜的最大值）</p><p>​        注意到当$X=V_1,Y=V_2,A=\Sigma$，$\lambda$是边集上的随机均匀分布，则该2P1R Game与上述Label Cover完全等价，$\omega(G)$就等于<strong>MAX-LC($\Sigma$)</strong>问题最优可满足比（证明者采用最优赋值方案即可）。为了$\omega(G)$缩小（甚至可以缩小为任意小的常数），我们可以并行进行该博弈$k$次。定义并行博弈$G^k$如下：</p><ul><li>$P_1$的问题集合为$X^k$，$P_2$的问题集合为$Y^k$。</li><li>答案集合为$A^k$。</li><li>验证者根据分布$\lambda$独立选择问题$(x_1,y_1),…,(x_k,y_k)$。</li><li>验证者发送$x_1,…,x_k$给$P_1$，发送$y_1,…,y_k$给$P_2$。</li><li>$P_1$返回答案$a_1,…,a_k$，$P_2$返回答案$b_1,…,b_k$。</li><li>证明者获胜当且仅当$V\left(x_{1}, y_{1}, a_{1}, b_{1}\right) \wedge \cdots \wedge V\left(x_{k}, y_{k}, a_{k}, b_{k}\right)$。</li></ul><p>从直觉上来看重复运行$k$次，$\omega(G)$确实是能减小的（事实上确实如此，但这并不是一个平凡的结论）。可以把对应的证明系统看成是查询复杂性不变，但是字母表变大了（$\Sigma^k$），一次查询的是原来字母表中的$k$个元素。那么$\omega(G)$究竟能减小多少呢？一个平凡的猜想是$\omega(G^k)=\omega(G)^k$，Fortnow，Rompel，Sipser也猜想如此，然而该结论并不正确，Feige找出了一个反例”Noninteractive Agreement Game”。计算$\omega(G^k)$具体的值是一件相当困难的任务，下一小节我们将分析为什么并行重复博弈是非平凡的。</p><h2 id="4-3-为什么并行重复博弈是非平凡的？"><a href="#4-3-为什么并行重复博弈是非平凡的？" class="headerlink" title="4.3 为什么并行重复博弈是非平凡的？"></a>4.3 为什么并行重复博弈是非平凡的？</h2><p>本节我们来分析Feige找出的反例”Noninteractive Agreement Game”（简称NA Game）的非平凡性。</p><p><strong>定义4.4”NA 2P1R Game”: </strong>不妨将两个证明者记为$P_0, P_1$。</p><ul><li>验证者选择两个随机均匀的比特$b_0,b_1$，将$b_0$发送给$P_0$，$b_1$发送给$P_1$。</li><li>证明者$P_0$返回两个比特$u_0, v_0$，证明者$P_1$返回两个比特$u_1,v_1$。</li><li>证明者获得胜利当且仅当<ul><li>$(u_0,v_0)=(u_1,v_1)$。</li><li>$(b_{u_0}=v_0)$。</li></ul></li></ul><p>我们可以很简单地计算$w(NA)$的值。首先注意到$P_0$可以设置$u_0=0,v_0=b_0$，这样第二个条件永远能被满足。$P_2$也可以将$u_1$永远设置为$0$，然而为了满足第一个条件，必须要让$v_1=b_0$才行，但是$b_0$与$b_1$是独立的两个比特，所以$P_2$猜中$b_0$的概率为$1/2$，也就是说$w(NA)=1/2$。</p><p>​        那么$w(NA^2)$的值是$(1/2)^2=1/4$吗？我们来看如果将该Game并行两次会发生什么？</p><p><strong>定义4.5”Parallel NA 2P1R Game”: </strong>不妨将两个证明者记为$P_0, P_1$。</p><ul><li>验证者选择随机均匀的比特$b_{00},b_{01},b_{10},b_{11}$，将$b_{00},b_{10}$发送给$P_0$，$b_{01},b_{11}$发送给$P_1$。</li><li>证明者$P_0$返回比特$u_{00},v_{00},u_{10},v_{10}$，证明者$P_1$返回比特$u_{01},v_{01},u_{11},v_{11}$。</li><li>证明者获得胜利当且仅当<ul><li>$(u_{00},v_{00})=(u_{01},v_{01})$。</li><li>$(u_{10},v_{10})=(u_{11},v_{11})$。</li><li>$(b_{0,u_{00}}=v_{00})$。</li><li>$(b_{1,u_{11}}=v_{11})$。</li></ul></li></ul><p>注意到此时$P_0$将$u_{00}$设置为$0$，$v_{00}$设置为$b_{00}$，则第3个条件将永远能被满足，同时$P_0$可将$u_{10}$永远设置为$1$，将$v_{10}$设置为$b_{00}$。同理，$P_1$将$u_{11}$设置为$1$，$v_{11}$设置为$b_{11}$，则第4个条件将永远能被满足，同时$P_1$可将$u_{01}$永远设置为0，将$v_{01}$设置为$b_{11}$。在这种策略下，证明者成功当且仅当$b_{00}=b_{11}$，该事件发生的概率恰好为$1/2$。也就是说$w(NA^2)$的值并不是$1/4$，而是$1/2$！重复并行一次Game并没有降低证明者获胜的概率。</p><p>​        将该Game并行进行$k$次之后，$w(NA^k)$的值是多少呢？Feige证明了如下定理：</p><p><strong>定理4.6[Feige91]：</strong>若$k$是偶数，则$w(NA^k)=2^{-k/2}=(1/\sqrt{2})^k$。</p><p>也就是说证明者获胜的概率确实是随着$k$的增大指数级减小的。事实上对于任何2P1R Game，该现象都会发生，这就是复杂性领域著名的Parallel Repetition Theorem。</p><h2 id="4-4-Gap无限放大：-Parallel-Repetition定理"><a href="#4-4-Gap无限放大：-Parallel-Repetition定理" class="headerlink" title="4.4 Gap无限放大： Parallel Repetition定理"></a>4.4 Gap无限放大： Parallel Repetition定理</h2><p>​        1995年，Raz证明了如下定理：</p><p><strong>定理4.5[Raz95]”Parallel Repetition Theorem”：</strong>令$s<1$ 以及$|a|$为两个常数，则存在$s^{\prime}<1$（仅依靠于$s$和$a$）使得对于任意的2p1r game g，若该game的答案集合为$a$且$w(g)="s$，则对于任意的$k">1$，有$w(G^k)&lt;(s^{\prime})^k$。</1$></p><p>注意到如果令$k=O(\log 1/\epsilon)$，则有$w(G^k)&lt;\epsilon$并且答案集合的大小为poly($1/\epsilon$)。此时我们可以将Label Cover问题的实例看成是一个2P1R Game G，并将该Game并行重复$O(\log 1/\epsilon)$次，该Game仍然是一个Label Cover问题实例，可以验证并行重复仍然保持正则与投影属性。所以我们可以从Parallel Repetition Theorem得到如下定理。</p><p><strong>定理4.6：</strong>对于任意的常数$\epsilon&gt;0$，存在字母表$\Sigma$，使得<strong>$GAP-LC(\Sigma)_{1, s}$</strong>是NP-hard的。</p><p>​        注意该定理与引理4.2的区别，引理4.2说的是存在，该定理说的是任意。也就是说我们可以将Lable Cover的问题的gap进行无限放大，该问题仍然还是NP难问题。作为Parallel Repetition Theorem的推论我们可以得到字母表的大小$\Sigma$的大小为$|\Sigma|^k=poly(1/\epsilon)$（Pretty Cool~）。定理4.6的完整证明同样出现在Raz95年的论文中，在94年，Feige与Kilian给出了部分的证明，但是他们没有保持Lable Cover问题的投影属性（在那时可能人们没有意识到投影属性的重要性）。之后，在期刊版本的论文中，他们给出了另一种方法保持投影属性，并同样证明了定理4.6，然而Feige与Kilian的证明得到的字母表大小为$|\Sigma|=2^{poly(1/\epsilon)}$。Parallel Repetition定理的证明相当困难，Holenstein于2006年对该证明进行了简化与改进[Holenstein06]，但是看懂它仍然是非常困难的事情（至少我觉得比PCP定理难多了orz）。由于<strong>$GAP-LC(\Sigma)_{1, s}$</strong>的gap可以任意大，所以该问题也成为了证明其他问题不可近似性的“母问题”。</p><h1 id="5-你是一名“独裁者”吗？Hastad’s-3-query-PCP"><a href="#5-你是一名“独裁者”吗？Hastad’s-3-query-PCP" class="headerlink" title="5. 你是一名“独裁者”吗？Håstad’s 3-query PCP"></a>5. 你是一名“独裁者”吗？Håstad’s 3-query PCP</h1><h2 id="5-1-Max-E3LIN2问题"><a href="#5-1-Max-E3LIN2问题" class="headerlink" title="5.1 Max-E3LIN2问题"></a>5.1 Max-E3LIN2问题</h2><p>​        上一章中我们得到了关于Lable Cover问题不可近似性的相当Cool的结论，对于任意的常数$\epsilon&gt;0$，存在字母表$\Sigma$，<strong>MAX-LC($\Sigma$)</strong>不存在近似比为$\epsilon$的多项式时间算法，我们对不可近似性的理解又往前加深了一步。本章中我们将利用Lable Cover问题，证明Max-E3LIN2问题的不可近似性，该问题可以很简单地归约到Max-E3SAT问题（见第6章）。</p><p>​        Max-E3LIN2问题说的是一个解线性方程组的问题，给定一系列形如$x_{i_1}+x_{i_2}+x_{i_3}=b_i(\mod 2) $的方程，给出一种赋值方案，使得该方程组中尽可能有多的方程能被满足。虽然该问题从表面上看只是一个解线性方程组的问题，但是它是NP难问题。为了获得该问题的不可近似性，我们可以构造某种满足特定要求的PCP系统（回忆第3章的内容），该证明系统的验证者的验证形式只能是从证明中获取3个比特，并验证它们的异或（XOR）是否等于某个特定的值，从这种证明系统中我们就能获得一个E3LIN2问题的实例（验证者的每次验证就相当于一个方程）。1997年，Håstad给出了如下的证明系统：</p><p><strong>定理5.1(Håstad97)”Håstad’s 3-query PCP”: </strong>对于任意的常数$\epsilon,\delta$，$\mathcal{NP} \subseteq \mathcal{PCP}_{1-\epsilon,1/2+\delta}[O(\log n),3]_{\{0,1\}}$，验证者的验证形式是从证明中获取3个比特，并判断这3个比特的XOR是否等于某个特定的值。</p><p>该定理也表明对于任意的常数$\epsilon,\delta$，$GAP-E3LIN2_{1-\epsilon,1/2+\delta}$问题是NP难的。</p><p>​        接下来，我们从Label Cover问题出发，构造形如定理5.1所述的PCP系统。回忆上一章我们得到了对于任意的$\gamma&gt;0$，$GAP-LC(\Sigma)_{1,\gamma}$都是NP难的，对于该问题的一个实例$((G=(V_1,V_2),E),\Sigma,\Pi)$以及赋值方案$\sigma$，我们能很自然地想到如下的证明系统：</p><ul><li>随机选取一条边$e=(u,v)\in E$。</li><li>验证$\Pi_e(\sigma(u))=\sigma(v)$。</li></ul><p>该证明系统的Completeness为1，Soundness为$\gamma$，但是这两次查询对应的字母表规模相当大（$|\Sigma|=poly(1/\gamma)$）。为了仅仅读取3个比特，我们可以对字母表中的元素用某种特殊的方式进行编码，当验证$\Pi_e(a)=b$时，不需要完整读取$a,b$的所有内容。</p><h2 id="5-2-“独裁者”测试"><a href="#5-2-“独裁者”测试" class="headerlink" title="5.2 “独裁者”测试"></a>5.2 “独裁者”测试</h2><p>​        我们选取long codes作为编码方案，对于$a\in \Sigma=\{1,…,m\}$，其对应的long code定义为</p><script type="math/tex; mode=display">LONG(a)=Had(e_a)=(x \cdot e_a)_{x\in\{0,1\}^m}=(x_a)_{x\in\{0,1\}^m}</script><p>其中$e_a$为$\{0,1\}^m$中的向量，第$a$个分量为1，其余为0。该编码方案将长度为$\log m$的字符串编码为长度为$2^m$的字符串。为了方便后续的处理，我们用$+1,-1$来表示$0,1$（熟悉布尔函数的同学应该明白这样处理的方便性）。则$a$对应的码字$LONG(a)$可以可以看成是一个布尔函数$LONG(a)=A:\{1,-1\}^m\rightarrow \{1,-1\}$，并且$A(x)=x_a$，该函数也被称为“独裁者”函数，因为该函数的输出只和第$a$位有关。</p><p>​        如果证明者提供了一段编码，那么我们如何来判断这个码字是某个元素$a$的long code呢？也就是说我们如何判断一个布尔函数是“独裁者”？假设$A:\{1,-1\}^m\rightarrow \{1,-1\}$确实是某个元素$a$的long code，则有$A(x)=x_a$，$A(y)=y_a$，且$A(xy)=x_ay_a=A(x)A(y)$，则一个简单的想法是检查$A(x)A(y)A(xy)=1$是否成立。然而，这种测试方法有一个大问题，所有的线性函数都能以1的概率通过该测试方案（事实上，这就是线性测试中的BLR testing方案），所以需要考虑另一种方法。</p><p>​        我们可以在该测试中加入少许“噪音”，根据如下分布选择$\mu \in \{1,-1\}^m$（每一位都独立选取）</p><script type="math/tex; mode=display">\mu_{i}=\left\{\begin{array}{ll}1 & \text { with probability } 1-\epsilon / 2 \\-1 & \text { with probability } \epsilon / 2\end{array}\right.</script><p>显然$\mathbb{E}\left[\mu_{i}\right]=1-\epsilon$，考虑下面的测试方案：</p><ol><li>随机均匀选取$x,y \in \{1,-1\}^m$。</li><li>根据上述分布选择$\mu \in \{1,-1\}^m$。</li><li>检查$A(x)A(y)A(xy\mu)=1$是否成立。</li></ol><p>下面简要分析该测试方案的完备性与稳健性。</p><p><strong>完备性（Completeness）：</strong>假设$A=LONG(a)$，则该测试就是检查$x_ay_ax_ay_a\mu_a=\mu_a=1$是否成立，根据上述分布，该事件发生的概率为$1-\frac{\epsilon}{2}&gt;1-\epsilon$。</p><p><strong>稳健性（Soundness）：</strong>如果该函数是线性函数$A=\chi_{S}$但是$|S|$较大，则该测试相当于检测$\chi_{S}(x) \chi_{S}(y) \chi_{S}(x y \mu)=\chi_{S}(\mu)=1$，也就是说是$\chi_{S}(\mu)=\prod_{i \in S} \mu_{i}=1$。该测试通过的概率为$\mathbb{E}\left[\frac{1+\chi_{S}(\mu)}{2}\right]=\frac{1}{2}+\frac{1}{2} \cdot \mathbb{E}\left[\chi_{S}(\mu)\right]$。接下来我们可以计算出$\mathbb{E}\left[\chi_{S}(\mu)\right]=\mathbb{E}\left[\prod_{i \in S} \mu_{i}\right]=\prod_{i \in S} \mathbb{E}\left[\mu_{i}\right]=(1-\epsilon)^{|S|}$，所以当$|S|$较大时该结果趋向于0，事实上当$|S| \gg \frac{1}{\epsilon}$时该值最多为$\epsilon$。也就是说我们证明了该测试方案的Soundness不超过$1/2+\epsilon$。</p><h2 id="5-3-Hastad’s-3-query-PCP"><a href="#5-3-Hastad’s-3-query-PCP" class="headerlink" title="5.3 Håstad’s 3-query PCP"></a>5.3 Håstad’s 3-query PCP</h2><p>​        根据上一小节的”独裁者“测试方案，我们可以建立定理5.1所述的PCP系统，回忆起该证明系统需要验证者仅仅查询3个比特，然后验证这3个比特的异或是否等于某个特定比特，也就是说该验证形如$x_{1} \oplus x_{2} \oplus x_{3}=b$的形式。</p><p>​        再次考虑$GAP-LC(\Sigma)_{1,\gamma}$问题的一个实例，随机选择其中一条边$e=(u,v)$，判断该边是否满足约束$\pi$。假设$\sigma$为证明者提供的赋值方案，则为了执行该验证，我们查询$u$对应的赋值$\sigma(u)$，$v$对应的赋值$\sigma(v)$，检查$\pi_{e}(\sigma(u))=\sigma(v)$是否成立。注意到该证明系统只需要两次查询，但是这两次查询都在一个非常大的字母表$\Sigma$上。我们需要证明系统的字母表为$\{0,1\}$，并且查询复杂性恰好为3，允许证明的Soundness增加到$1/2$。假设$A$与$B$分别是$\sigma(v)$与$\sigma(u)$对应的long codes，字母表$\Sigma$的大小为$m$，将$\pi_e$简写为$\pi$。随机选择$x,y\in \{-1,1\}^m$，验证$A(x) B(y) B((x \circ \pi) y \mu)=1$是否成立（该验证对应到01上就是异或验证），其中$\mu \in \{1,-1\}^m$满足上述5.2节中的分布。该证明系统的查询复杂性恰好为3，字母表为$\{0,1\}$。该证明系统有如下属性：</p><p><strong>定理5.2：</strong>给定一个Lable Cover问题的难实例G，该PCP系统满足</p><ul><li>完备性：若存在一种赋值方案使得G中所有约束都能被满足，则验证者接受的概率大于$1-\epsilon$。</li><li>稳健性：如果验证者接受的概率大于$1/2+\delta$，则G中存在一种赋值方案使得能被满足的约束大于$\epsilon’$（$\epsilon’$和$\delta$,$\epsilon$有关。）</li></ul><p>注意到$\epsilon$是选择$\mu \in \{-1,1\}^m$时任取的一个常数，根据Label Cover问题的不可近似性以及上述定理，我们可以推出定理5.1，也就是说对于任意的常数$\epsilon,\delta$，$GAP-E3LIN2_{1-\epsilon,1/2+\delta}$问题是NP难的。</p><h1 id="6-最后的碎片：从Max-E3LIN2归约到Max-E3SAT"><a href="#6-最后的碎片：从Max-E3LIN2归约到Max-E3SAT" class="headerlink" title="6. 最后的碎片：从Max-E3LIN2归约到Max-E3SAT"></a>6. 最后的碎片：从Max-E3LIN2归约到Max-E3SAT</h1><p>最后，让我们回归到<strong>Max-E3SAT</strong>问题，找出近似算法的极限在哪。</p><p><strong>定理6.1</strong>：对于任意常数$\epsilon&gt;0$，<strong>Max-E3SAT</strong>不存在近似比为$7/8+\epsilon$的多项式时间算法，除非$\mathcal{P}=\mathcal{NP}$。</p><p><strong>证：</strong>构造从<strong>Max-E3LIN2</strong>到<strong>Max-E3SAT</strong>的规约。给定一个<strong>Max-E3LIN2</strong>的实例$\phi$，输出<strong>Max-E3SAT</strong>问题的实例$\psi$。$\psi$中变量与$\phi$中变量相同，对于$\phi$中的一个等式，$\psi$中对应有4个子句。若$\phi$中等式为$x+y+z=0 \mod 2$，则$\psi$中对应的4个子句为$\bar{x} \vee \bar{y} \vee \bar{z}, \bar{x} \vee y \vee z, x \vee \bar{y} \vee z,$ 以及$x \vee y \vee \bar{z}$。当$\phi$中的某个等式能被满足时，$\psi$中对应的4个子句都能被满足。反之若$\phi$中的某个等式不能被满足，则$\psi$中的四个子句至多有3个能被满足。所以如果在$\phi$中有至少$1-\epsilon$的等式能被满足，则$\psi$中一样至少$1-\epsilon$的子句能被满足。如果$\phi$中至多有$1/2+\epsilon$的等式能被满足，则$\psi$中能被满足的子句个数最多为$\frac{4(1/2+\epsilon)+3(1/2-\epsilon)}{4}=7/8+\epsilon/4 \leq 7/8+\epsilon$的子句。根据第5章所述，对于任意的常数$\epsilon&gt;0$，$GAP-E3LIN2_{1-\epsilon,1/2+\epsilon}$问题是NP难的，所以$GAP-E3SAT_{1-\epsilon,7/8+\epsilon}$也是$\mathcal{NP}$难的，也就是说对于任意常数$\epsilon&gt;0$，<strong>Max-E3SAT</strong>不存在近似比为$7/8+\epsilon$的多项式时间算法。</p><p>终于，我们得到了<strong>Max-E3SAT</strong>问题的最优近似比是$7/8$，也就是说对表达式中每个变量随机均匀赋值就是<strong>Max-E3SAT</strong>问题的最优算法。从<strong>Max-E3LIN2</strong>问题能得出其他若干问题的不可近似，如：</p><p><strong>定理6.2：</strong>对于任意常数$\epsilon&gt;0$，最大割问题<strong>Max-CUT</strong>不存在近似比为$16/17+\epsilon$的多项式时间算法，除非$\mathcal{P}=\mathcal{NP}$。</p><p><strong>定理6.3：</strong>对于任意常数$\epsilon&gt;0$，<strong>Max-2SAT</strong>不存在近似比为$21/22+\epsilon$的多项式时间算法，除非$\mathcal{P}=\mathcal{NP}$。</p><p><strong>定理6.4：</strong>对于任意常数$\epsilon&gt;0$，顶点覆盖问题<strong>Vertex-Cover</strong>不存在近似比为$7/6-\epsilon$的多项式时间算法，除非$\mathcal{P}=\mathcal{NP}$。</p><p>证明留给读者。对于最大割问题<strong>Max-CUT</strong>，如果假设<strong>UGC</strong>(Unique Game Conjecture)成立的话，则该问题的最优近似比为$0.878…$，最优算法用到了半正定规划<strong>SDP</strong>(Semidefinite Programming)，下次预计会写点这方面的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 计算复杂性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP Completeness </tag>
            
            <tag> Hardness of Approximation </tag>
            
            <tag> PCP Theorem </tag>
            
            <tag> Parallel Repetition Theorem </tag>
            
            <tag> Property Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息认证编码，认证加密</title>
      <link href="/2020/12/08/mac-1/"/>
      <url>/2020/12/08/mac-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-消息认证编码-定义"><a href="#1-消息认证编码-定义" class="headerlink" title="1. 消息认证编码-定义"></a>1. 消息认证编码-定义</h1><p>消息认证编码的目的是为了保护消息在传输过程中不被攻击者修改，接收者能验证消息的完整性。</p><h2 id="1-1-消息认证编码的定义"><a href="#1-1-消息认证编码的定义" class="headerlink" title="1.1. 消息认证编码的定义"></a>1.1. 消息认证编码的定义</h2><p>一个消息认证编码MAC（Message Authentication Code）由三个概率多项式（Gen, Mac, Vrfy）时间的算法构成： </p><ol><li>Gen: 输入安全参数$1^n$, 输出密钥$k$, 要求$|k| \geq n$.</li><li>Mac: 输入密钥$k$, 消息$m \in \{0, 1\}^*$, 输出标签tag, $t \leftarrow Mac_k(m)$.</li><li>Vrfy: 输入密钥$k$, 标签$t$, 输出比特$b \leftarrow Vrfy_k(m, t)$. 若$b=1$, 则表示“有效”，反之表明“无效”。</li></ol><p>正确性要求$Vrfy_k(m, Mac_k(m))=1$.</p><h2 id="1-2-MAC的安全性定义"><a href="#1-2-MAC的安全性定义" class="headerlink" title="1.2 MAC的安全性定义"></a>1.2 MAC的安全性定义</h2><p>给定一个MAC方案$\Pi $，考虑如下游戏：</p><ol><li>挑战者运行$Gen(1^n)$，获得密钥$k$.</li><li>攻击者输入$1^n$, 适应性地进行消息查询，将消息记为$m_1, m_2, \cdots , m_{q}$. 挑战者返回对应的MAC $t_1, t_2, \cdots, t_{q}$.</li><li>攻击者宣布其挑战消息$m$, 并生成对应的MAC $t$.</li><li>攻击者成功当且仅当（1）$Vrfy_k(m, t) = 1$ 并且（2）$m \notin \{m_1, m_2, \cdots , m_{q}\}$.</li></ol><p>将上述游戏中攻击者$A$成功的概率记为<strong>$Pr[S]$</strong>.</p><p>一个MAC方案$\Pi$在适应性选择明文攻击下是存在不可伪造的EU-CMA（Existentially Unforgeable under an adaptive Chosen-Message Attack）如果对于所有的概率多项式时间算法$A$, 存在一个可忽略的函数$negl(n)$, 使得：</p><p><strong>$Pr[S] \leq negl(n)$</strong>.</p><h1 id="2-构造安全的MAC"><a href="#2-构造安全的MAC" class="headerlink" title="2. 构造安全的MAC"></a>2. 构造安全的MAC</h1><h2 id="2-1-固定消息长度的MAC方案"><a href="#2-1-固定消息长度的MAC方案" class="headerlink" title="2.1 固定消息长度的MAC方案"></a>2.1 固定消息长度的MAC方案</h2><p><strong>Construction 2.1：</strong></p><p>假设$F$为伪随机函数，定义消息长度为$n$的MAC方案：</p><ol><li>$Gen(1^n)$: 选择随机均匀密钥$k \leftarrow \{0,1\}^{n}$, 并输出。</li><li>$Mac(m, k)$: 输出标签$t:=F_k(m)$.（若$|m| \neq |k|$则不输出任何值。）</li><li>$Vrfy(k,m,t)$: 若$t=F_k(m)$, 则输出1，反之输出0.</li></ol><p><strong>Theorem 2.2：</strong>若$F$为伪随机函数，则上述构造为安全的定长MAC方案。</p><p><strong>Proof：</strong>假设$A$为一个概率多项式时间的攻击者，定义两个游戏Game 0, Game 1.</p><p><strong>Game 0:</strong></p><ol><li>挑战者选择密钥$k \leftarrow \{0, 1\}^{n}$.</li><li>攻击者适应性地查询$Q = \{m_1, \cdots, m_q\}$ 对应的tag, 挑战者返回$\{t_1, \cdots, t_q\}$, 其中$t_i = F_k(m_i)$.</li><li>攻击者输出消息-tag对$(m, t)$, 若$t=F_k(m), m \notin Q$, 则攻击者成功。</li></ol><p>将攻击者在Game 0中成功的概率记为$S_0$.</p><p>将伪随机函数改为真随机函数$f$, 得到Game 1.</p><p><strong>Game 1:</strong></p><ol><li>挑战者选择密钥$k \leftarrow \{0, 1\}^{n}$.</li><li>攻击者适应性地查询$Q = \{m_1, \cdots, m_q\}$ 对应的tag, 挑战者返回$\{t_1, \cdots, t_q\}$, 其中$t_i = f(m_i)$.</li><li>攻击者输出消息-tag对$(m, t)$, 若$t=f(m), m \notin Q$, 则攻击者成功。</li></ol><p>将攻击者在Game 1中成功的概率记为$S_1$.</p><p><strong>Claim 1</strong>: $Pr[S_1] = 2^{-n}$ .</p><p><strong>Proof of Claim 1:</strong> 显然当$m$从未被查询过时，$f(m)$的值为$\{0,1\}^{n}$上的随机元素，刚好取到$t$的概率为$2^{-n}$.</p><p><strong>Claim 2:</strong> $|Pr[S_0] - Pr[S_1]| \leq negl(n)$.</p><p><strong>Proof of Claim 2:</strong> 我们使用归约论证来证明该结论，假设攻击者$A$能成功伪造MAC, 我们构造新的算法D来区分真随机函数与伪随机函数。</p><p><strong>算法D:</strong></p><p>算法D的输入为$1^n$, 并且D能查询预言$O: \{0,1\}^n \rightarrow \{0,1\}^n$, 该算法的作用为区分$O$究竟是 真随机函数还是伪随机函数。</p><ol><li><p>运行$A(1^n)$, 当$A$用消息$m$来查询MAC预言时，如下回答：</p><p>(a)用$m$查询预言$O$, 返回值记为$t$, 将$t$值给$A$.</p></li><li><p>当$A$结束运行并输出$(m,t)$时：</p><p>(a)用$m$查询预言$O$, 返回$t’$.</p><p>(b)如果$t=t’$并且$A$之前从来没有查询过$m$, 则输出1, 反正输出0.</p></li></ol><p>显然，D是多项式时间算法。</p><p><strong>算法D的分析：</strong></p><p><strong>Case 1:</strong> 当$D$的预言$O$是伪随机函数时，攻击者$A$在Game 0中，此时$D$输出1当且仅当$A$在Game 0中成功，所以，</p><p>$Pr[D^{F_k(\cdot)}(1^n)=1]=Pr[S_0]$.</p><p><strong>Case 2:</strong> 当$D$的预言$O$是真随机函数时，攻击者$A$在Game 1中，此时$D$输出1当且仅当$A$在Game 1中成功，所以，</p><p>$Pr[D^{f(\cdot)}(1^n)=1]=Pr[S_1]$.</p><p>因为$F_k$为伪随机函数，所以我们有：</p><p>$|Pr[S_0]-Pr[S_1]| = |Pr[D^{F_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]|\leq negl(n)$.</p><p>Claim 2证明完毕。</p><p>结合Claim 1​和Claim 2我们有$|Pr[S_0]-2^{-n}| \leq negl(n)$, 即$Pr[S_0] \leq 2^{-n}+negl(n)$是可忽略的。</p><p>所以攻击者A成功伪造的概率可忽略，构造2.1是安全的MAC方案。</p><h2 id="2-2-任意消息长度的MAC方案"><a href="#2-2-任意消息长度的MAC方案" class="headerlink" title="2.2. 任意消息长度的MAC方案"></a>2.2. 任意消息长度的MAC方案</h2><p>假设$\Pi’=(Mac’, Vrfy’)$是定长的MAC方案，将$m$进行分块获得$m_1, \cdots, m_d$.</p><p><strong>思路1:</strong> 直接分块计算$t_i:=Mac_k^{‘}(m_i)$, 输出$<t_1,t_2,\cdots,t_d>$. 但这无法抵抗<strong>块重排序攻击</strong>，假设$(t_1, t_2)$为$(m_1, m_2)$对应的有效MAC. 则攻击者知道$(m_2, m_1)$对应的有效MAC是$(t_2,t_1)$.</t_1,t_2,\cdots,t_d></p><p><strong>思路2:</strong> 在每个块上加上块指数$i$, $t_i := Mac’_k(i||m_i)$, 这就能抵御<strong>块重排序攻击</strong>。但这无法抵御<strong>截断攻击</strong>，攻击者直接将最后一个区块去掉。比如$(t_1, t_2)$为$(m_1, m_2)$对应的有效MAC. 则攻击者知道$m_1$对应的有效MAC是$t_1$.</p><p><strong>思路3:</strong> 每个块上加上消息的长度$l$, $t_i:=Mac’_k(l||i||m_i)$, 这能抵御<strong>截断攻击</strong>，因为截断后长度改变。但这无法抵挡<strong>混淆攻击</strong>。比如攻击者已知$(m_1,m_2)$的MAC值为$(t_1,t_2)$, $(m’_1, m’_2)$的MAC值为$(t’_1,t’_2)$. 则攻击者能知道$(m_1, m’_2)$的MAC值为$(t_1, t’_2)$.</p><p><strong>Construction 2.3:</strong></p><p>假设$\Pi’=(Mac’, Vrfy’)$是固定长度$n$的MAC方案，则如下定义一个新的MAC：</p><ol><li><p>$Gen(1^n)$: 选择随机均匀密钥$k \leftarrow \{0,1\}^{n}$, 并输出。</p></li><li><p>$Mac(m, k)$: 输入的消息$m \in \{0,1\}^*$长度为$l &lt; 2^{n/4}$. 将 $m$ 分成 $d$ 个块$m_1, m_2, \cdots, m_d$, 每个块长度为$n/4$（最后的块用0补足）。选择随机标识符$r \in \{0,1\}^{n/4}$.</p><p>对于$i=1,2,\cdots,d$, 计算$t_i \leftarrow Mac’_k(r||l||i||m_i)$, $i, l$都用$n/4$长度的字符串来表示。输出标签$t=(r,t_1,t_2,\cdots, t_d)$.</p></li><li><p>$Vrfy(k,m,t)$: 输入标签$t = (r,t’_1, \cdots, t’_{d’})$，输入的消息$m \in \{0,1\}^*$长度为$l &lt; 2^{n/4}$. 将$m$分成$d$个块$m_1, m_2, \cdots, m_d$, 每个块长度为$n/4$（最后的块用0补足）。首先验证$d=d’$是否成立，其次对于$1\leq i \leq d$ 验证$t’_i=Mac’_k(r||l||i||m_i)$. 若验证均通过，输出1，反之输出0.</p></li></ol><p><strong>Theorem 2.4:</strong> 假设$\Pi’$为长度为$n$安全的定长MAC方案，那么上述构造是任意长度的安全MAC方案。</p><p> <strong>Proof:</strong> 假设$A$为概率多项式时间的攻击者，我们把$A$成功伪造上述MAC方案记为事件$S$, 我们要证明$Pr[S]$是可忽略的。</p><p>符号说明：</p><p>令$(m,t=<r,t_1,\cdots>)$为攻击者最后的输出，其中$m=m_1, \cdots$.</r,t_1,\cdots></p><p><strong>Repeat:</strong> 攻击者查询MAC预言得到的一系列tag值中，有两个随机标识符一样。</p><p><strong>NewBlock</strong>: 至少有一个块$r||l||i||m_i$在A的预言查询时从来未被$Mac’_k$认证过。</p><p>$Pr[S]=Pr[S \land Repeat]+Pr[S \land \overline{Repeat} \land NewBlock]+Pr[S \land \overline{Repeat} \land \overline{NewBlock}]$</p><p>$\leq Pr[Repeat]+Pr[S \land NewBlock]+Pr[S \land \overline{Repeat} \land \overline{NewBlock}]$</p><p>我们证明右边三个概率都是可忽略的。</p><p><strong>Claim 1:</strong> $Pr[Repeat]$是可忽略的。</p><p><strong>Proof of Claim 1</strong>: 令事件$H_{i,j}$为第$i$次查询和第$j$次查询选择的随机标识符一致。则由于标识符的长度为$2^{n/4}$, 我们有$Pr[H_{i,j}]=\frac{1}{2^{n/4}}$. 假设攻击者查询的次数为$q(n)$, $q$为某个多项式，那么</p><p>$Pr[Repeat] = Pr[\cup_{1 \leq i &lt; j \leq q(n)} H_{i,j}] = \sum_{i,j} Pr[H_{i,j}] = C_{q(n)}^2\frac{1}{2^{n/4}} \leq \frac{q(n)^2}{2^{n/4}}$</p><p>该值为可忽略的值。</p><p><strong>Claim 2:</strong> $Pr[S \land \overline{Repeat} \land \overline{NewBlock}]=0$</p><p>我们证明如果攻击者伪造成功且MAC查询时随机标识符都不相同，则<strong>NewBlock</strong>必然发生。</p><p><strong>Proof of Claim 2:</strong> 再次假设$q=q(n)$为攻击者进行MAC查询的次数。事件<strong>Repeat</strong>没有发生，则$r_1,r_2,…,r_q$各不相同。若$r \notin \{r_1,r_2,…,r_q\}$, 则显然<strong>NewBlock</strong>发生。</p><p>若存在$j$, 使得$r=r_j$, 假设$r_j$为攻击者第$j$次查询的标识符，对应的消息为$m^{(j)}$, 长度为$l_j$.</p><p><strong>Case 1:</strong> $l \neq l_j$, 则所有块的第二个分量都不一样，显然块$r||l||1||m_1$从未被查询过。<strong>NewBlock</strong>显然发生。</p><p><strong>Case 2:</strong> $l = l_j$, 则由于攻击者伪造成功了，我们有$m \neq m^{(j)}$. 假设$m$与$m^{(j)}$的第$i$个块不一致，即$m_i \neq m_i^{(j)}$. 那么显然$r||l||i||m_i$是新的块。<strong>NewBlock</strong>也发生。</p><p>综上所述，$S \land \overline{Reapeat}$ 发生则<strong>NewBlock</strong>一定发生。 $Pr[S \land \overline{Repeat} \land \overline{NewBlock}] = 0$.</p><p><strong>Claim 3:</strong> $Pr[S \land NewBlock]$是可忽略的。</p><p>我们用归约来证明Claim 3，假设有多项式时间攻击者$A$成功伪造MAC，我们构造新的多项式时间攻击者$A$来伪造方案$\Pi’$的MAC，这与我们的假设相反。</p><p><strong>Proof of Claim 3:</strong> </p><p>攻击者$A’$: 输入为$1^n$, 能用$Mac’_k(\cdot)$进行MAC预言查询。</p><p>​    把攻击者$A$当成子程序。</p><ol><li><p>当攻击者$A$用 $m$（长度为 $l$）进行$Mac_k(\cdot)$查询时:</p><p>(a)将$m$分成长度为$n/4$的块$m_1, m_2,…m_d$（假设有$d$个块），最后不够的用0补足。</p><p>(b)随机选择标识符$r \in \{0,1\}^{n/4}$, 对于$1 \leq i \leq d$, 用 $r||l||i||m_i$ 查询预言$Mac’_k(\cdot)$得到$t_i$.</p><p>(c)返回 $<r,t_1,...,t_d>$.</r,t_1,...,t_d></p><ol><li>当攻击者$A$输出伪造$(m, t = <r,t_1,...,t_d>$时，检查$NewBlock$是否发生：</r,t_1,...,t_d></li></ol><p>(a)若发生，假设$r||l||i||m_i$是新的块从未被认证过，则输出$<r||l||i||m_i, t_i>$.</r||l||i||m_i,></p><p>(b)若未发生，输出失败。</p></li></ol><p>显然，攻击者$A$作为$A’$的子程序时和在原始的攻击游戏中完全一致。</p><p>假设$NewBlock$ 发生，则块 $r||l||i||m_i$ 从来未被认证过。</p><p>假设$S$发生，攻击者$A$伪造成功，则所有块的tag值均有效，$t_i = Mac’_k(r||l||i||m_i)$. </p><p>所以如果$S \land NewBlock$发生，则攻击者$A’$成功伪造了$r||l||i||m$ 的MAC值。</p><p>假设攻击者$A’$成功的事件为$S’$, 我们有$Pr[S \land NewBlock] \leq Pr[S’]$. 根据我们的假设 $\Pi’$ 为安全的MAC方案，所以$Pr[S’]$可忽略，从而得到 $Pr[S \land NewBlock]$ 可忽略。</p><p>综合Claim 1,2,3, $Pr[S]$可忽略，该方案是安全的MAC方案。</p><h1 id="3-CBC-MAC"><a href="#3-CBC-MAC" class="headerlink" title="3. CBC-MAC"></a>3. CBC-MAC</h1><p>上一节构造的MAC方案效率低，比如计算消息长度为$dn$的MAC值，需要进行$4d$次分组计算，最后的tag长度为$4dn$. 本节给出更有效的构造。</p><h2 id="3-1-基本构造"><a href="#3-1-基本构造" class="headerlink" title="3.1. 基本构造"></a>3.1. 基本构造</h2><p><strong>Construction 3.1:</strong></p><p>假设$F$是伪随机函数，固定长度函数$l&gt;0$. 基本的CBC-MAC方案如下构造：</p><ol><li><p>$Gen(1^n)$: 随机选择$k \leftarrow \{0, 1\}^n$, 输出作为密钥。</p></li><li><p>$Mac(k, m)$: 输入消息的长度为$l(n) \cdot n$, 进行如下计算：</p><p>(a). 将$m$分成$m_1, m_2, … , m_l$, 每个$m_i$的长度为$n$.</p><p>(b). 令$t_0=0^n$, 对于$i$从1到$l$, 计算：</p><p>​        $t_i = F_k(t_{i-1} \oplus m_i)$.</p><p>(c). 输出$t_l$作为tag.</p></li><li><p>$Vrfy(t, m, k)$: 若$m$的长度不是$l(n) \cdot n$ 输出0，否则输出1当且仅当$t = Mac(k, m)$. </p></li></ol><p><strong>Theorem 3.2:</strong> 假设F是伪随机函数，$l$为多项式，则上述方案对于长度为$l(n) \cdot n$的消息来说是安全的MAC方案。</p><p>下一节证明一个更一般的结论。</p><h2 id="3-2-安全性证明"><a href="#3-2-安全性证明" class="headerlink" title="*3.2. 安全性证明"></a>*3.2. 安全性证明</h2><p><strong>本节稍有难度，可以选择跳过不影响后面学习。</strong></p><p>定义CBC函数，输入为$(\{0,1\}^n)^*$中的元素（也就是长度为n的倍数）以及长度为n的密钥映射到长度为n的字符串。</p><p>$CBC_k(x_1,…,x_l)=F_k(F_k( \cdots F_k(F_k(x_1) \oplus x_2) \oplus \cdots ) \oplus x_l)$.</p><p>$|x_1|=|x_2|=\cdots=|x_l|=|k|=n$.</p><p>一个字符串集合$P \subset (\{0,1\}^n)^*$是无前缀的如果它不包含空串以及任何字符串 $X \in P$ 都不是其它字符串 $X’ \in P$ 的前缀。</p><p><strong>Theorem 3.3:</strong> 对于任意的概率多项式时间算法$D$, $D$ 能进行预言查询，但所有查询的字符串构成的集合是无前缀的。存在可忽略的函数$negl$, 使得，</p><p>$|Pr[D^{CBC_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]| \leq negl(n)$.</p><p>我们可以用一个编码函数$encode$, 将任意长度的字符串$m$映射到 $encode(m) \in (\{0,1\}^n)^*$, 然后输出$CBC_k(encode(m))$. 该编码方案需要是无前缀的。</p><p>我们证明当CBC的“密钥”是一个随机函数$g$时的安全性，也就是说定义</p><p>$CBC_g(x_1,…,x_l)=g(g( \cdots g(g(x_1) \oplus x_2) \oplus \cdots ) \oplus x_l)$.</p><p>我们证明$CBC_g(\cdot)$与$(\{0,1\}^n)^*$到$\{0,1\}^n$上的随机函数就是不可区分。</p><p><strong>Theorem 3.4:</strong> 固定$n \geq 1$, 取随机函数$g:\{0,1\}^n \rightarrow \{0, 1\}^n, f:$$(\{0,1\}^n)^* \rightarrow \{0,1\}^n$, 对于任意（无时间限制）算法$D$, $D$ 能进行$q$次预言查询，但这$q$次查询的字符串构成的集合是无前缀的，并且所有的查询中最长的消息包含$l$个区块。则</p><p>$|Pr[D^{CBC_g(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]| \leq \frac{q^2 l^2}{2^n}$.</p><p><strong>Proof of Theorem 3.4:</strong> 假设$P=\{X_1,…,X_q\}$为无前缀的q次查询，每个$X_i \in (\{0, 1\}^n)^*$, 且$P$中最长的消息包含$l$个区块。对于任意的$t_1,…,t_q \in \{0,1\}^n$, 有$Pr[\forall i:f(X_i)=t_i] = 2^{-nq}$.</p><p>我们称CBC是$(q,l,\delta)-smooth$的如果对于每个无前缀集合$P=\{X_1,…,X_q\}$,  以及每个$t_1,…,t_q \in \{0,1\}^n$ ,有</p><p>$Pr[\forall i: CBC_g(X_i)=t_i] \geq (1-\delta) \cdot 2^{-nq}$.</p><p>也就是说 $(q,l,\delta)-smooth$ 的CBC是 $\delta-close$ 真随机函数 $f$ 的。</p><p><strong>Claim 3.5:</strong> $CBC_g$是$(q,l,\delta)-smooth$的，其中 $\delta = q^2l^2 \cdot 2^{-n}$.</p><p><strong>下面假设Claim 3.5成立。</strong></p><p>定义函数$\alpha(X_1,…,X_q;t_1,…, tq) = 1$当且仅当$D$查询$X_1,…,X_q$时返回$t_1,…,t_q$, 且$D$最后输出1.</p><p>令$\overrightarrow{X} = \{X_1,…,X_q\}$, $\overrightarrow{t} = \{t_1,…,t_q\}$, 我们有</p><p>$\operatorname{Pr}\left[D^{\mathrm{CBC}_{g}(\cdot)}\left(1^{n}\right)=1\right]$</p><p>$=\sum_{\vec{X} \text { prefix-free; } \vec{t}} \alpha(\vec{X}, \vec{t}) \cdot \operatorname{Pr}\left[\forall i : \mathrm{CBC}_{g}\left(X_{i}\right)=t_{i}\right]$</p><p>$\geq \sum_{\vec{X} \text { prefix-free; } \vec{t}} \alpha(\vec{X}, \vec{t}) \cdot(1-\delta) \cdot \operatorname{Pr}\left[\forall i : f\left(X_{i}\right)=t_{i}\right]$</p><p>$=(1-\delta) \cdot \operatorname{Pr}\left[D^{f(\cdot)}\left(1^{n}\right)=1\right]$,</p><p>这证明了</p><p>$\operatorname{Pr}\left[D^{f(\cdot)}\left(1^{n}\right)=1\right]-\operatorname{Pr}\left[D^{\mathrm{CBC}_{g}(\cdot)}\left(1^{n}\right)=1\right] \leq \delta \cdot \operatorname{Pr}\left[D^{f(\cdot)}\left(1^{n}\right)=1\right] \leq \delta$.</p><p>完成<strong>Theorem 3.4</strong>的证明。</p><p>下面进行Claim 3.5的证明。</p><p><strong>Proof of Claim 3.5:</strong> </p><p>令$X \in\left(\{0,1\}^{n}\right)^{*}$, 且$X=x_1,…$并且$, |x_i|=n$.</p><p>令$C_g(x)$是 计算$CBC_g(X)$过程中$g$的输入构成的集合。例如假设$X \in\left(\{0,1\}^{n}\right)^{m}$, 那么</p><p>$\mathcal{C}_{g}(X) \stackrel{\mathrm{def}}{=}\left(x_{1}, \mathrm{CBC}_{g}\left(x_{1}\right) \oplus x_{2}, \ldots, \mathrm{CBC}_{g}\left(x_{1}, \ldots, x_{m-1}\right) \oplus x_{m}\right)$.</p><p>令$X \in\left(\{0,1\}^{n}\right)^{m}$, $X’ \in\left(\{0,1\}^{n}\right)^{m’}$.</p><p>$C_g(X)=(I_1,…,I_m), C_g(X’)=(I’_1,…,I’_{m’})$.</p><p>称$X$内部存在非平凡碰撞如果存在 $I_i=I_j$ 但是 $i \neq j$.</p><p>称$X,X’$之间存在非平凡碰撞如果存在 $I_i = I’_j$ 但是$\left(x_{1}, \ldots, x_{i}\right) \neq\left(x_{1}^{\prime}, \ldots, x_{j}^{\prime}\right)$.</p><p>称字符串集合$P=\{X_1,…,X_q\}$ 存在非平凡碰撞若存在 $X \in P$ 有内部碰撞或者存在$X,X’ \in P$之间存在碰撞。</p><p>定义事件 $Coll$ 为集合P存在非平凡碰撞。</p><p>我们分两部来完成证明：</p><p>第一步：如果 $Coll$ 未发生，则 $\operatorname{Pr}\left[\forall i : \operatorname{CBC}_{g}\left(X_{i}\right)=t_{i} | \overline{\mathrm{Coll}}\right]=2^{-n q}$.</p><p>第二步：证明 $Coll$ 发生的概率小于$\delta \leq q^2l^2\cdot 2^{-n}$.</p><p>对于$X$, 随机均匀选择 $g(I_1)$ 的值，确定$I_2=g(I_1) \oplus x_2$, 随机均匀选择$g(I_2)$的值，如此重复，直到选择 $g(I_{m-1})$ 的随机值（无需选取$g(I_m)$的值，因为$g(I_m) \notin C_g(X)$）。用上述方式计算出字符串$X_1,…,X_q$对应的$C_g(X_1),…,C_g(X_q)$，然后就可检查事件 $Coll$ 是否发生。</p><p>假设事件$Coll$未发生，那么$C_g(X_1),…,C_g(X_q)$中的最后一项必不相同。我们证明$g$在这些最后一项上的值未被确定，假设$C_g(X)$的最后一项$I_m$的$g$值已经被确定，那么肯定存在$I’_j$, $I_m = I’_j$并且 $I’_j$ 不是$C_g(X’)$的最后一项。但是由于事件$Coll$未发生，上述事件只有当$(x_1,…,x_m) = (x’_1,…,x’_j)$发生时才发生，但由于$X \neq X’$, 我们得到$X$是$X’$的前缀，这与$P$无前缀相矛盾。</p><p>$CBC_g(X_i)$的值就是$g$在$C_g(X_i)$上最后一项的值。根据上述分析，$g$在最后一项上的值未被确定，所以从$\{0,1\}^n$上独立均匀选出，选择到某个固定值的概率为$2^{-n}$. 选择任意的$t_1,…,t_q \in \{0,1\}^n$, 有</p><p>$\operatorname{Pr}\left[\forall i : \operatorname{CBC}_{g}\left(X_{i}\right)=t_{i} | \overline{\mathrm{Coll}}\right]=2^{-n q}$.</p><p>第一步证明完毕，下面进行第二步证明。</p><p>给定$X_i, X_j \in P$, 令$Coll_{i,j}$为$X_i, X_j$中内部存在碰撞或者$X_i,X_j$之间存在碰撞，则</p><p>$Coll =\lor_{i, j} \text { Coll }_{i, j}$,</p><p>$\operatorname{Pr}[\mathrm{Coll}] \leq \sum_{i, j : i&lt;j} \operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right]=\left(\begin{array}{c}{q} \ {2}\end{array}\right) \cdot \operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right] \leq \frac{q^{2}}{2} \cdot \operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right]$.</p><p>令$X=X_i, X’=X_j$, 两者的块长度都是$l$. $X=(x_1,…,x_l), X’=(x’_1,…,x’_l)$, $t$是最大的整数使得</p><p>$(x_1,…,x_t)=(x’_1,…,x’_t)$.（其中 $t &lt; l$ 否则 $X=X’$）</p><p>注意到此时$(I_1,…,I_t) = (I’_1,…,I’_t)$.</p><p>用下面 $2l-t-2$ 步来确定 $g$ 的值：</p><p>$i$ 从1到 $t-1$ :</p><p>​    随机均匀选择$g(I_i)$的值从而确定 $I_{i+1}$和$I’_{i+1}$.（注意这步两者相等）</p><p> $i = t$ :</p><p>​    随机均匀选择$g(I_t)$的值从而确定 $I_{t+1}$和$I’_{t+1}$.（注意这步两者不等）</p><p> $i$ 从 $t+1$ 到 $l-1$:</p><p>​    随机均匀选择 $g(I_{t+1}),g(I_{t+2}),…,g(I_{l-1})$ 的值从而确定 $I_{t+2}, I_{t+3},…,I_{l}$.</p><p>$i$ 从 $l$ 到 $2l-t-2$:</p><p>​    随机均匀选择 $g(I’_{t+1}),g(I’_{t+2}),…,g(I’_{l-1})$ 的值从而确定 $I’_{t+2}, I’_{t+3},…,I’_{l}$.</p><p>假设事件$Coll(k)$表示第$k$步发生了非平凡碰撞，那么</p><p>$\operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right]=\operatorname{Pr}\left[\lor_{k} \operatorname{Coll}(k)\right] \leq \operatorname{Pr}[\operatorname{Coll}(1)]+\sum_{k=2}^{2l-t-2} \operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}]$.</p><p>若 $k&lt;t$, $Coll(k-1)$未发生，则$(I_1,..,I_k)$各不相同，$I_{k+1}=g(I_k) \oplus x_{k+1}$与前$k$个值发生碰撞的概率为$\frac{k}{2^n}$, 所以$\operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}]=k / 2^{n}$.</p><p>若 $k=t$, $\operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}] \leq 2t / 2^{n}$, 因为这一步生成了两个值$I_{t+1}, I’_{t+1}$且不相同。</p><p>若 $k &gt; t$, $\operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}] \leq (k+1) / 2^{n}$, 因为第$t$步多生成了一个值，所以加上1.</p><p>我们得出</p><p>$\operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right] \leq 2^{-n} \cdot\left(\sum_{k=1}^{t-1} k+2 t+\sum_{k=t+1}^{2l-t-2}(k+1)\right) $</p><p>$= 2^{-n} \cdot \sum_{k=2}^{2l-t-1} k=2^{-n} \cdot(2 l - t+1) \cdot(2l - t-2)/2 &lt; 2 \ell^{2} \cdot 2^{-n}$.</p><p>所以，我们有</p><p>$Pr[Coll] \leq \frac{q^2}{2}Pr[Coll_{i,j}] &lt; q^2l^2 \cdot 2^{-n} = \delta$.</p><p>综合所有，我们有</p><p>$Pr[\forall i: CBC_g(X_i)=t_i] \geq Pr[\forall i: CBC_g(X_i)=t_i|\overline{Coll}] \cdot Pr[\overline{Coll}] \geq 2^{-nq}\cdot Pr[\overline{Coll}] \geq (1-\delta)\cdot2^{-nq}$.</p><p>这就证明了 $CBC_g$ 是$(q,l,\delta)-smooth$的。</p><h1 id="4-认证加密"><a href="#4-认证加密" class="headerlink" title="4. 认证加密"></a>4. 认证加密</h1><p>如何设计加密方案使其既保证安全性又保证消息的完整性？</p><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1. 定义"></a>4.1. 定义</h2><p>我们规定密文必须满足某种条件，攻击者无法伪造出有效的密文。</p><p>考虑攻击者与挑战者$A$之间不可伪造的加密游戏：</p><ol><li>挑战者运行$Gen(1^n)$获得私钥$k$.</li><li>攻击者$A$输入$1^n$以及可以用消息$m_i$进行加密查询，挑战者计算$c_i=Enc_k(m_i)$并返回。</li><li>攻击者$A$最后输出一段密文$c$.</li><li>令$Q$表示攻击者进行的加密查询集合，挑战者计算$m=Dec_k(c)$, 若密文无效输出$\perp$.攻击者在该游戏中成功当且仅当$m \neq \perp$且$m \notin Q$.</li></ol><p>把上述攻击者成功的事件记为事件$S$.</p><p><strong>定义4.1: </strong>我们称一个对称加密方案 $\Pi$ 是不可伪造的，如果对于任意的概率多项式时间攻击者，存在一个可忽略的函数 $negl$ 使得$Pr[S] \leq negl(n)$.</p><p><strong>定义4.2:</strong> 如果一个加密方案是CCA安全并且不可伪造的，那么称该方案是一个认证加密。</p><h2 id="4-2-通用构造"><a href="#4-2-通用构造" class="headerlink" title="4.2. 通用构造"></a>4.2. 通用构造</h2><p>假设$\Pi_E=(Enc,Dec)$为CPA安全的加密方案，$\Pi_M=(Mac, Vrfy)$ 为MAC方案，$k_E, k_M$为对应方案的密钥。考虑下面三种方案：</p><ol><li><strong>加密并认证：</strong>密文为$<c,t>$, 其中$c \leftarrow Enc_{k_E}(m), t \leftarrow Mac_{k_M}(m)$. 接收者先解密得到$m$, 再验证$Vrfy(m,t)=1$是否成立，若成立，输出$m$, 反之输出错误。</c,t></li><li><strong>先认证，再加密：</strong>密文为$c$, 先计算$t \leftarrow Mac_{k_M}(m)$, 再计算$c \leftarrow Enc_{k_E}(m||t)$. 接收者先解密得到$m||t$, 再验证$Vrfy(m,t)=1$是否成立，若成立，输出$m$, 反之输出错误。</li><li><strong>先加密，再认证：</strong>密文为$<c,t>$, 先计算$c \leftarrow Enc_{k_E}(m)$, 再计算$t \leftarrow Mac_{k_M}(c)$, 接收者先验证$Vrfy(c,t)=1$是否成立，若成立解密出$m$, 反之输出错误。</c,t></li></ol><p>注意MAC方案不保证不泄露原文的一些消息，所以直接计算明文的MAC值并作为密文的一部分并不安全，方案1，2不适用。</p><p>考虑第3种方案，先加密，后认证：</p><p><strong>Construction 4.3:</strong> </p><p>假设$\Pi_E=(Enc,Dec)$为私钥加密方案，$\Pi_M=(Mac, Vrfy)$ 为消息认证编码。定义如下的私钥加密方案：</p><ol><li>$Gen’$: 随机均匀选择密钥$k_E, k_M \in \{0,1\}^n$.</li><li>$Enc’$: 输入消息$m$以及密钥$k_E, k_M$, 计算$c \leftarrow Enc_{k_E}(m)$, 再计算$t \leftarrow Mac_{k_M}(c)$, 输出密文$<c,t>$.</c,t></li><li>$Dec’$: 输入密文$<c,t>$, 密钥$k_E, k_M$, 首先验证$Vrfy(c, t)=1$是否成立，若成立，输出$m=Dec_{k_E}(c)$, 反之输出$\perp$.</c,t></li></ol><p><strong>Theorem 4.4:</strong> 假设$\Pi_E$为CPA安全的私钥加密方案，$\Pi_M$是安全的消息认证编码，则上述构造为一个认证加密方案。</p><p><strong>Proof of Theorem 4.4:</strong> 非形式化地说，由于密文包含 $c$ 的MAC值，而由于我们假设$\Pi_M$是不可伪造的MAC方案，所以攻击者无法伪造出$c$的MAC值，也就是说无法伪造出有效的密文。这就说明了该方案是不可伪造的方案。并且由于密文不可伪造性，攻击者进行解密查询的密文都是无效的（有可忽略的概率可能有效），解密预言返回$\perp$, 所以解密预言并没有给攻击者额外的帮助，所以若 $\Pi_E$ 是CPA安全的话，该方案是CCA安全的。</p><p>假设$A$是概率多项式时间的攻击者在CCA-Game中攻击构造4.3.</p><p>称密文$<c,t>$是新的如果$A$没从加密预言中获得过$<c,t>$.</c,t></c,t></p><p>定义事件$ValidQuery$为$A$提交给解密预言的密文是新的且是有效的，$Vrfy(c,t)=1$.</p><p><strong>Claim 4.5:</strong> $Pr[ValidQuery]$是可以忽略的。</p><p><strong>Proof of Claim 4.5:</strong> 令$q(n)$为攻击者$A$进行解密查询的次数，我们构造新的攻击者$A_M$, 把$A$作为子程序调用，在MAC伪造Game中攻击MAC方案$\Pi_M$.</p><p>攻击者$A_M$: 输入$1^n$, 允许其能进行MAC预言查询$Mac_{k_M}(\cdot)$.</p><ol><li><p>$k_E \leftarrow \{0,1\}^n, i \in \{1,2,…,q(n)\}$.</p></li><li><p>当$A$用$m$进行加密查询时：</p><p>(1). $c \leftarrow Enc_{k_E}(m)$,</p><p>(2). 用$c$进行MAC预言查询，获得$c \leftarrow Mac_{k_M}(\cdot)$. 将$<c,t>$返回给$A$.</c,t></p><p>(3). 用同样的方式生成挑战密文。</p></li><li><p>当$A$用$<c,t>$进行解密查询时，若这恰好是第$i$次查询，$A_M$直接输出$<c,t>$, 否则：</c,t></c,t></p><p>(1). 若$<c,t>$是之前$A$用$m$加密查询生成的，直接返回$m$.</c,t></p><p>(2). 否则输出$\perp$.</p></li></ol><p>显然$A_E$是概率多项式时间算法。</p><p>直观上看，$A_M$预测$A$第$i$次查询 $<c,t>$ 是新的且有效的查询。则 $<c,t>$ 从未被$A_M$查询过，$A_M$ 成功伪造了$c$ 的MAC值$t$. </c,t></c,t></p><p>令事件$S_M$为$A_M$成功伪造了$MAC$值。$A$进行新且有效查询的概率为$Pr[ValidQuery]$, 该查询恰好是第$i$次查询的概率为$Pr[ValidQuery]/q(n)$. 所以$Pr[S_M] = Pr[ValidQuery]/q(n)$. 而我们假设 $\Pi_M$ 是安全的MAC方案，所以$Pr[S_M]$是可忽略的，而又$q(n)$是多项式，所以$Pr[ValidQuery]$ 也是可忽略的。</p><p>下面证构造3.5 $\Pi’$ 是密文不可伪造的。</p><p>假设攻击者 $A’$ 能对方案 $\Pi’$ 进行密文伪造，$A$将$A’$作为子程序调用，当$A’$成功伪造$<c,t>$时，$A$ 用 $<c,t>$进行密文查询。但是我们已经证明$A$进行有效密文查询的概率可忽略，所以$A’$伪造成功的概率也可忽略，所以 $\Pi’$ 是不可伪造的加密方案。</c,t></c,t></p><p>下面证$\Pi’$ 是CCA安全的。</p><p>令事件 $S$ 为攻击者$A$在CCA游戏中成功击破了方案$\Pi’$.</p><p>$Pr[S] = Pr[S \land ValidQuery]+Pr[S \land \overline{ValidQuery}] \leq Pr[ValidQuery] + Pr[S \land \overline{ValidQuery}]$.</p><p>已知$Pr[ValidQuery]$可忽略，所以只要证明如下Claim.</p><p><strong>Claim 4.6:</strong> $Pr[S \land \overline{ValidQuery}] \leq \frac{1}{2}+negl(n)$.</p><p><strong>Proof of Claim 4.6:</strong> 直观上看由于$ValidQuery$事件未发生，所有解密查询都是无效的，解密预言未提供任何额外能力，所以如果$\Pi_E$是CPA安全的话，$\Pi’$也是CCA安全的。</p><p>我们构造攻击者$A_E$在CPA-Game中攻击方案$\Pi_E$.</p><p>攻击者$A_E$: 输入为$1^n$, 能进行加密查询$Enc_{k_E}(\cdot)$.</p><ol><li><p>$k_M \leftarrow \{0,1\}^n$.</p></li><li><p>当$A$用消息$m$进行加密查询时，</p><p>(1). 用$m$进行加密查询$Enc_{k_E}(\cdot)$, 获得$c \leftarrow Enc_{k_E}(\cdot)$.</p><p>(2). 计算$t \leftarrow Mac_{k_M}(c)$, 将$<c,t>$返回给$A$.</c,t></p></li><li><p>当$A$用$<c,t>$进行解密查询时，</c,t></p><p>(1). 若$<c,t>$是之前消息$m$加密查询的返回值，直接输出$m$.</c,t></p><p>(2). 反之，输出$\perp$.</p></li><li><p>$A$提交两段等长明文$m_0, m_1$, </p><p>(1). $A_E$ 将这两段明文提交给自己的挑战者得到挑战密文$c$.</p><p>(2). 计算$t \leftarrow Mac_{k_M}(c)$, 将$<c,t>$作为$A$的挑战密文.</c,t></p></li><li><p>当$A$输出1个bit后，$A_E$ 输出相同的bit.</p></li></ol><p>显然，$A_E$是概率多项式时间的算法。</p><p>当事件$ValidQuery$未发生时，$A$作为$A_E$的子程序与在原始的CCA-Game中完全一致。</p><p>令事件$S_E$为$A_E$在CPA-Game中成功。从上述算法中我们可得，$A_E$成功当且仅当$A$成功，所以</p><p>$Pr[S_E \land \overline{ValidQuery}] = Pr[S \land \overline{ValidQuery}]$.</p><p>我们得出</p><p>$Pr[S_E] \geq Pr[S_E \land \overline{ValidQuery}] = Pr[S \land \overline{ValidQuery}]$</p><p>又 $\Pi_E$ 是CPA安全的，$Pr[S_E] \leq 1/2 + negl(n)$. 所以$Pr[S \land \overline{ValidQuery}] \leq \frac{1}{2}+negl(n)$.</p><p>所以，$Pr[S] \leq Pr[ValidQuery] + Pr[S \land \overline{ValidQuery}] \leq 1/2 + negl’(n)$.</p><p>$\Pi’ $ 是CCA安全的方案。</p><p>综上$\Pi’$是安全的认证加密方案。</p><h2 id="4-3-CCA安全加密"><a href="#4-3-CCA安全加密" class="headerlink" title="4.3. CCA安全加密"></a>4.3. CCA安全加密</h2><p>可伪造与CCA安全不等价，存在可伪造但还是CCA安全的方案。</p><p>认证加密与CCA安全其实也不等价，CCA安全方案与认证加密目的不同，认证加密我们要求的是消息的完整性与安全性，CCA安全不考虑消息的完整性，只考虑能进行解密查询的敌手。在公钥加密体制中，CCA安全方案与认证加密的区别较大。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息认证编码 </tag>
            
            <tag> 认证加密 </tag>
            
            <tag> CCA安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/12/08/hello-world/"/>
      <url>/2020/12/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
