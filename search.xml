<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Max-E3SAT问题的不可近似性：从Cook-Levin到Håstad&#39;s E3-SAT Hardness</title>
      <link href="/2020/12/11/max-3sat/"/>
      <url>/2020/12/11/max-3sat/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>​        这学期花费了一段时间看了一遍Venkatesan Guruswami和Ryan O’Donnell两位大神关于PCP定理和不可近似性的lecture notes。<strong>PCP</strong>定理本身不必多说，后面关于不可近似性的内容也属实精彩。一直想写点东西把这方面的知识从头到尾总结一下，于是就诞生了这篇文章。本文预计从1971年Stephen Cook证明<strong>3SAT</strong>是$\mathcal{NP}$完全问题开始说起，一直到2001年Håstad证明7/8是<strong>Max-3SAT</strong>问题的最优近似比结束，把这30年的研究历史简要概括一下，不涉及到一些证明的细节，我感兴趣的部分可能会展开详细说一下。由于本人水平实在不行，有任何写得不对的地方或者有问题的地方欢迎大家指出。</p><p>​        关于<strong>SAT</strong>问题，相信每个对计算理论有点了解的同学都不陌生，<strong>SAT</strong>问题说的是输入一个布尔表达式，问是否存在一种赋值方案，使得该布尔表达式被满足（结果为1）. 所谓的<strong>3SAT</strong>问题，指的就是该布尔表达式是一个合取范式(CNF)，该CNF中每个子句(clause)的变量个数不超过3个。如果每个子句变量的个数都恰好为3个的话，那么该问题称为<strong>E3SAT</strong>问题，一个<strong>E3SAT</strong>问题的实例(instance)如下：</p><script type="math/tex; mode=display">F=(x_1 \lor \overline{x_2} \lor x_5) \land (\overline{x_1} \lor \overline{x_3} \lor x_4) \land (\overline{x_2} \lor x_3 \lor x_5)</script><p>在上述实例中，对变量赋值$x=(1,0,0,1,1)$就能使得上述表达式的值为1，也就是说该表达式是能被满足的。那么我们能否设计一个高效（多项式时间）的算法来判定<strong>E3SAT</strong>问题呢？</p><p>​        上述所说的几种<strong>SAT</strong>问题，指的都是判定问题（Decision Problem），也就是说这些问题的输出为$1$或者$0$，如果输入的表达式能满足的话就输出$1$，反之输出$0$。在理论计算机领域中，通常我们把一个判定问题结果为1的所有输入构成的集合称为是一个语言$\mathcal{L}$。比如<strong>E3SAT</strong>问题对应的语言就是所有能被满足的<strong>3CNF</strong>表达式构成的集合。如果要求把最优赋值方案找出来，使得它能满足最多的子句，那这种问题称为搜索问题（Search Problem）记为<strong>Max-E3SAT</strong>。显然搜索问题不会比判定问题简单。</p><p>​        顺便一提，如果<strong>3SAT</strong>问题能在多项式时间内判定，并且输入的<strong>3CNF</strong>表达式能被满足的话，那该表达式的赋值方案也能在多项式时间内求解出来。假设存在多项式时间的算法D能判定<strong>3SAT</strong>问题，我们可以构造一个新的多项式时间的算法S找出能满足的赋值方案。比如输入的<strong>3SAT</strong>问题实例是$F$，有$n$个变量，先调用一次D，如果D返回能满足，我就先把$x_1$赋值为0，然后把得到的$F_1$再次提交给D，如果D返回能满足，我接下来就把$x_2$进行赋值……如果D返回不能满足的话，那我就明白把$x_1$赋值为1是一定能满足的，接着把赋值后的表达式再次提交给D。如此反复，也就是说我只要重复调用D $n$次就能把该赋值找出来。</p><h1 id="2-一切的起始：Cook-Levin定理"><a href="#2-一切的起始：Cook-Levin定理" class="headerlink" title="2. 一切的起始：Cook-Levin定理"></a>2. 一切的起始：Cook-Levin定理</h1><h2 id="2-1-Cook-Levin定理概述"><a href="#2-1-Cook-Levin定理概述" class="headerlink" title="2.1 Cook-Levin定理概述"></a>2.1 Cook-Levin定理概述</h2><p>​        很遗憾，Stephen Cook告诉我们，<strong>SAT</strong>问题是不存在多项式时间的算法的，除非$\mathcal{P}=\mathcal{NP}$。1971年Cook大神在读博期间发表了一篇名为 “The Complexity of Theorem Proving Procedures”的文章，该文章形式化地定义了复杂性领域中的两个基本概念“多项式时间规约（Polynomial-time Reduction）”和“$\mathcal{NP}$完全（$\mathcal{NP}$-Completeness）”。规约，指的就是把一个问题实例转化成另一个问题的实例，并保持实例的一些属性。比如从图的3着色问题规约到SAT问题，输入一个图，经过规约算法后输出一个布尔表达式，该布尔表达式可满足当且仅当输入的图是可以进行3着色的。所谓的$\mathcal{P}$问题，指的就是能在多项式时间求解的问题。$\mathcal{NP}$问题，指的是能在多项式时间内被验证的问题，$\mathcal{NP}$问题的解也称为witness。$\mathcal{NP}$完全问题指在$\mathcal{NP}$中难度最大的问题，更严谨来说，$\mathcal{NP}$完全问题是一种特殊的$\mathcal{NP}$问题，其他所有的$\mathcal{NP}$问题都能在多项式时间内规约到它。Cook也在该篇文章中证明了第一个$\mathcal{NP}$完全问题：<strong>SAT</strong>。1982年，Cook因为该项工作获得图灵奖。</p><p><strong>定理 2.1[Cook71]”Cook-Levin定理”：</strong> <strong>SAT</strong>是$\mathcal{NP}$完全的。</p><p>我们可以简单地从<strong>SAT</strong>问题规约到<strong>E3SAT</strong>问题上来，所以<strong>E3SAT</strong>问题也是$\mathcal{NP}$完全的。</p><p>​        这篇文章也留下了计算机科学领域最著名的问题：$\mathcal{P}=\mathcal{NP}$？也就是说多项式时间内能验证的问题是否一定能在多项式时间内求解？通过$\mathcal{NP}$完全的定义我们可以意识到，如果$\mathcal{NP}$完全问题能在多项式时间内求解的话，那么所有$\mathcal{NP}$问题都将能在多项式时间内求解。所以如果<strong>E3SAT</strong>能在多项式时间内求解的话，那么所有$\mathcal{NP}$问题（像什么图的3着色啊，哈密顿回路啊等等）都能在多项式时间内求解。一般人都认为$\mathcal{P}$和$\mathcal{NP}$是不太可能相等的（某些怪人除外），所以为<strong>E3SAT</strong>问题寻找多项式时间的算法大部分人认为是不可行的。既然判定<strong>E3SAT</strong>问题是一个难问题，那为<strong>E3SAT</strong>的实例找出一种最优的赋值方案当然是更难的问题。</p><h2 id="2-2-我们能否找到近似解？"><a href="#2-2-我们能否找到近似解？" class="headerlink" title="2.2 我们能否找到近似解？"></a>2.2 我们能否找到近似解？</h2><p>​        既然无法设计一个多项式时间的算法判定<strong>E3SAT</strong>问题，那我们能不能设计一个有效的算法找出一种赋值方案使得它尽可能满足多的子句呢？很简单，只要对每个变量进行随机赋值即可！那大家思考一下，这样的赋值方案从期望来说能让多少个子句被满足呢？没错！只要进行这样的一种平凡赋值就能让$7/8$的子句获得满足。这是因为在随机赋值的情况下每个子句被满足的概率为$7/8$，假设该表达式中有$m$个句子，那根据Linearity of Expectation，期望上有$7/8\cdot m$的子句能被满足。通过Derandomization的方法可以将该算法转化成确定性算法，输出一种赋值方案满足$7/8$以上的子句。事实上，对于普通的<strong>3SAT</strong>问题，如果把某个实例中最多能被满足的子句数量记为$OPT$的话，我们也可以在多项式时间内找出一种赋值方案使得它能满足$7/8\cdot OPT$的子句[Karloff97]。</p><p>​        Cook-Levin定理告诉我们，找出<strong>Max-E3SAT</strong>问题的最优赋值方案（$100\%$）是困难的，通过上面的分析我们明白找到一个$7/8$的近似解是简单的（即$7/8$近似算法）。那么我们能否能找到效果更好的算法呢？比如$8/9, 9/10,…$ ？多项式时间算法能达到的最优的近似比是多少？从Cook-Levin定理提出的30年之后，该问题才得到了回答。</p><h1 id="3-“懒人”的证明系统：PCP定理"><a href="#3-“懒人”的证明系统：PCP定理" class="headerlink" title="3. “懒人”的证明系统：PCP定理"></a>3. “懒人”的证明系统：PCP定理</h1><h2 id="3-1-交互式证明系统"><a href="#3-1-交互式证明系统" class="headerlink" title="3.1 交互式证明系统"></a>3.1 交互式证明系统</h2><p>​        我们先抛开上述<strong>Max-E3SAT</strong>问题，把目光移向密码学界。1985年，Cook-Levin定理被证明后过了14年，密码学领域出现了一篇很有趣的论文”The Knowledge Complexity of Interactive Proof Systems”。作者为Goldwasser, Micali, 以及Rackoff[GMR85]。这篇论文的工作对密码学领域与计算复杂性领域产生了非常重大的影响，Goldwasser, Micali也由于该项工作（还有一些其他密码学上的贡献）获得了2012年图灵奖。有趣的是，这篇文章投稿过FOCS’83，STOC‘84，FOCS’84，但都被拒绝了，一直到STOC‘85才被接收。这篇文章定义了两个新的概念，称为交互式证明系统（Interactive Proof Systems）与零知识证明（Zero-Knowledge Proof Systems）。关于零知识证明方面，相信了解区块链的同学一定不陌生。这是一种非常神奇的证明系统，比如我想向你证明某个命题的准确性，我能在不泄露额外秘密的情况下让你相信一个命题的真假性。本文不会讲零知识证明方面的内容，有兴趣的同学可以看看Bar-Ilan University的<a href="https://cyber.biu.ac.il/event/the-9th-biu-winter-school-on-cryptography/" target="_blank" rel="noopener">零知识证明课程</a>。</p><p>​        那么什么是交互式证明系统呢？证明系统指的其实就是一个计算能力无限的证明者（Prover）与概率多项式时间的验证者（Verifier）双方的一个游戏，验证者借助证明者帮她判断某个命题的真假。我们首先回顾一下关于$\mathcal{NP}$的定义，$\mathcal{NP}$问题说的是在多项式时间内能判定的问题，那其实对于任何一个$\mathcal{NP}$问题都可以建立一个平凡的一轮证明系统——对于<strong>3SAT</strong>问题，证明者只要把最优的赋值方案发送给验证者即可，验证者可以自己验证该表达式能不能被满足。交互式证明系统指的是证明者验证者双方可以进行多轮的交互，并且验证者有coin-tossing的能力（也就是随机算法）。把所有能建立交互式证明的语言构成的集合称为$\mathcal{IP}$，$\mathcal{NP}$就是$\mathcal{IP}$的一个平凡子集。那么$\mathcal{IP}$包含$\mathcal{NP}$外的其他语言吗？事实上1990年Shamir证明了$\mathcal{IP}=\mathcal{PSPACE}$，也就是说任何多项式空间能判定的问题都可以建立一个交互式证明系统。</p><p>​        1988年，Michael Ben-Or, Goldwasser, Joe Kilian, 和Wigderson为了移除零知识证明中的某些密码学假设，提出了多证明者的交互式证明系统[BGKW88]。在这种证明系统中，证明者可以有多个并且相互之间不能进行通信。作者证明了多个证明者（多项式多个证明者）和两个证明者是等价的。把所有能建立此类证明系统的语言记为$\mathcal{MIP}$， Babai, Fortnow, and Lund证明了$\mathcal{MIP}=\mathcal{NEXP}$，也就是所有能在指数时间内验证的问题都可以设计一个多证明者的交互式证明系统。从直觉上考虑，两个证明者之间不能进行通信，所以证明者进行欺骗的概率就大大降低了，也就是说双证明者的证明复杂性要小于单证明者（验证者提问的次数减小了），这个直觉直接促使了后续PCP理论的诞生与发展（这篇文章的工作也促使了Derandomization领域的诞生与发展）。Fortnow，Rompel，Sisper证明了$\mathcal{MIP}$与一种叫Oracle Proof System的系统是等价的[FRS88]。</p><p><strong>引理3.1[FRS88]：</strong> 令$\mathcal{L}$是一个语言，$M$是概率多项式时间的oracle图灵机使得</p><ul><li>$x \in L \Rightarrow $ 存在一个Oracle $\mathcal{O}$使得$M^{\mathcal{O}}$以大于$c$的概率接受$x$。</li><li>$x \notin L \Rightarrow $ 对于任意的Oracle $\mathcal{O}$，$M^{\mathcal{O}}$以小于$s$的概率接受$x$。</li></ul><p>则语言$\mathcal{L}$存在一个双证明者的交互式证明协议。（$\mathcal{L} \in \mathcal{MIP}$）</p><p>Oracle 可以理解为$\mathcal{O}$是$M$的黑盒子程序，$M$可以不断地对$\mathcal{O}$进行提问，获得相应的回答。事实上，这个Oracle Proof System其实就是下文要说明的一个重要概念：概率可验证证明<strong>PCPs</strong>（Probabilistic Checkable Proofs）</p><h2 id="3-2-概率可验证证明"><a href="#3-2-概率可验证证明" class="headerlink" title="3.2 概率可验证证明"></a>3.2 概率可验证证明</h2><p>​        上文所提到的Oracle Proof System，其实可以理解为这么一回事，把这个Oracle $\mathcal{O}$看成是证明者提供的一段证明。证明者把关于某个命题的证明$\pi$写下来之后，验证者可以随机选择该证明中的几个位置来判断该命题是否是正确的，这其实就是概率可验证证明<strong>PCPs</strong>。</p><p><strong>定义3.2：</strong>令$\mathcal{L}$是一个语言，$M$是概率多项式时间的图灵机使得</p><ul><li>$x \in L \Rightarrow $ 存在证明 $\pi$ 明使得$M^{\pi}$以大于$c$的概率接受$x$。（$c$也成为该证明系统的完备性Completeness）</li><li>$x \notin L \Rightarrow $ 对于任意的证明 $\pi$，$M^{\pi}$以小于$s$的概率接受$x$。（$s$也成为该证明系统的稳健性Soundness）</li></ul><p>则称语言$\mathcal{L}$存在概率可验证证明，若$M$使用了$O(r(n))$个随机比特，查询了证明中的$O(q(n))$个位置，并且证明中的所有字符都是字母表$\Sigma$中的元素，则称$\mathcal{L} \in \mathcal{PCP}_{c,s}[r(n), q(n)]_{\Sigma}$. </p><p>​        </p><h2 id="3-3-Gap问题与不可近似性"><a href="#3-3-Gap问题与不可近似性" class="headerlink" title="3.3 Gap问题与不可近似性"></a>3.3 Gap问题与不可近似性</h2><h1 id="4-与“双子上帝”进行博弈：Parallel-Repetition定理"><a href="#4-与“双子上帝”进行博弈：Parallel-Repetition定理" class="headerlink" title="4. 与“双子上帝”进行博弈：Parallel Repetition定理"></a>4. 与“双子上帝”进行博弈：Parallel Repetition定理</h1><h2 id="4-1-Label-Cover问题"><a href="#4-1-Label-Cover问题" class="headerlink" title="4.1 Label Cover问题"></a>4.1 Label Cover问题</h2><h2 id="4-2-双证明者的一轮博弈（2P1R-Game）"><a href="#4-2-双证明者的一轮博弈（2P1R-Game）" class="headerlink" title="4.2 双证明者的一轮博弈（2P1R Game）"></a>4.2 双证明者的一轮博弈（2P1R Game）</h2><h2 id="4-3-为什么并行重复博弈是非平凡的？"><a href="#4-3-为什么并行重复博弈是非平凡的？" class="headerlink" title="4.3 为什么并行重复博弈是非平凡的？"></a>4.3 为什么并行重复博弈是非平凡的？</h2><h2 id="4-4-Gap无限放大：-Parallel-Repetition定理"><a href="#4-4-Gap无限放大：-Parallel-Repetition定理" class="headerlink" title="4.4 Gap无限放大： Parallel Repetition定理"></a>4.4 Gap无限放大： Parallel Repetition定理</h2><h1 id="5-你是一名“独裁者”吗？Hastad’s-3-query-PCP"><a href="#5-你是一名“独裁者”吗？Hastad’s-3-query-PCP" class="headerlink" title="5. 你是一名“独裁者”吗？Håstad’s 3-query PCP"></a>5. 你是一名“独裁者”吗？Håstad’s 3-query PCP</h1><h2 id="5-1-震惊！线性方程组也是难问题！（Max-E3LIN2问题）"><a href="#5-1-震惊！线性方程组也是难问题！（Max-E3LIN2问题）" class="headerlink" title="5.1 震惊！线性方程组也是难问题！（Max-E3LIN2问题）"></a>5.1 震惊！线性方程组也是难问题！（Max-E3LIN2问题）</h2><h2 id="5-2-“独裁者”测试"><a href="#5-2-“独裁者”测试" class="headerlink" title="5.2 “独裁者”测试"></a>5.2 “独裁者”测试</h2><h2 id="5-3-Hastad’s-3-query-PCP"><a href="#5-3-Hastad’s-3-query-PCP" class="headerlink" title="5.3 Håstad’s 3-query PCP"></a>5.3 Håstad’s 3-query PCP</h2><h1 id="6-最后的碎片：从Max-E3LIN-2归约到Max-E3SAT"><a href="#6-最后的碎片：从Max-E3LIN-2归约到Max-E3SAT" class="headerlink" title="6. 最后的碎片：从Max-E3LIN-2归约到Max-E3SAT"></a>6. 最后的碎片：从Max-E3LIN-2归约到Max-E3SAT</h1><p>最后，我们回到Max-E3SAT问题上来，证明$7/8$是Max-E3SAT问题最优的近似比。</p>]]></content>
      
      
      <categories>
          
          <category> 计算复杂性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP完全定理 </tag>
            
            <tag> 不可近似性 </tag>
            
            <tag> PCP定理 </tag>
            
            <tag> Parallel Repetition定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息认证编码，认证加密</title>
      <link href="/2020/12/08/mac-1/"/>
      <url>/2020/12/08/mac-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-消息认证编码-定义"><a href="#1-消息认证编码-定义" class="headerlink" title="1. 消息认证编码-定义"></a>1. 消息认证编码-定义</h1><p>消息认证编码的目的是为了保护消息在传输过程中不被攻击者修改，接收者能验证消息的完整性。</p><h2 id="1-1-消息认证编码的定义"><a href="#1-1-消息认证编码的定义" class="headerlink" title="1.1. 消息认证编码的定义"></a>1.1. 消息认证编码的定义</h2><p>一个消息认证编码MAC（Message Authentication Code）由三个概率多项式（Gen, Mac, Vrfy）时间的算法构成： </p><ol><li>Gen: 输入安全参数$1^n$, 输出密钥$k$, 要求$|k| \geq n$.</li><li>Mac: 输入密钥$k$, 消息$m \in \{0, 1\}^*$, 输出标签tag, $t \leftarrow Mac_k(m)$.</li><li>Vrfy: 输入密钥$k$, 标签$t$, 输出比特$b \leftarrow Vrfy_k(m, t)$. 若$b=1$, 则表示“有效”，反之表明“无效”。</li></ol><p>正确性要求$Vrfy_k(m, Mac_k(m))=1$.</p><h2 id="1-2-MAC的安全性定义"><a href="#1-2-MAC的安全性定义" class="headerlink" title="1.2 MAC的安全性定义"></a>1.2 MAC的安全性定义</h2><p>给定一个MAC方案$\Pi $，考虑如下游戏：</p><ol><li>挑战者运行$Gen(1^n)$，获得密钥$k$.</li><li>攻击者输入$1^n$, 适应性地进行消息查询，将消息记为$m_1, m_2, \cdots , m_{q}$. 挑战者返回对应的MAC $t_1, t_2, \cdots, t_{q}$.</li><li>攻击者宣布其挑战消息$m$, 并生成对应的MAC $t$.</li><li>攻击者成功当且仅当（1）$Vrfy_k(m, t) = 1$ 并且（2）$m \notin \{m_1, m_2, \cdots , m_{q}\}$.</li></ol><p>将上述游戏中攻击者$A$成功的概率记为<strong>$Pr[S]$</strong>.</p><p>一个MAC方案$\Pi$在适应性选择明文攻击下是存在不可伪造的EU-CMA（Existentially Unforgeable under an adaptive Chosen-Message Attack）如果对于所有的概率多项式时间算法$A$, 存在一个可忽略的函数$negl(n)$, 使得：</p><p><strong>$Pr[S] \leq negl(n)$</strong>.</p><h1 id="2-构造安全的MAC"><a href="#2-构造安全的MAC" class="headerlink" title="2. 构造安全的MAC"></a>2. 构造安全的MAC</h1><h2 id="2-1-固定消息长度的MAC方案"><a href="#2-1-固定消息长度的MAC方案" class="headerlink" title="2.1 固定消息长度的MAC方案"></a>2.1 固定消息长度的MAC方案</h2><p><strong>Construction 2.1：</strong></p><p>假设$F$为伪随机函数，定义消息长度为$n$的MAC方案：</p><ol><li>$Gen(1^n)$: 选择随机均匀密钥$k \leftarrow \{0,1\}^{n}$, 并输出。</li><li>$Mac(m, k)$: 输出标签$t:=F_k(m)$.（若$|m| \neq |k|$则不输出任何值。）</li><li>$Vrfy(k,m,t)$: 若$t=F_k(m)$, 则输出1，反之输出0.</li></ol><p><strong>Theorem 2.2：</strong>若$F$为伪随机函数，则上述构造为安全的定长MAC方案。</p><p><strong>Proof：</strong>假设$A$为一个概率多项式时间的攻击者，定义两个游戏Game 0, Game 1.</p><p><strong>Game 0:</strong></p><ol><li>挑战者选择密钥$k \leftarrow \{0, 1\}^{n}$.</li><li>攻击者适应性地查询$Q = \{m_1, \cdots, m_q\}$ 对应的tag, 挑战者返回$\{t_1, \cdots, t_q\}$, 其中$t_i = F_k(m_i)$.</li><li>攻击者输出消息-tag对$(m, t)$, 若$t=F_k(m), m \notin Q$, 则攻击者成功。</li></ol><p>将攻击者在Game 0中成功的概率记为$S_0$.</p><p>将伪随机函数改为真随机函数$f$, 得到Game 1.</p><p><strong>Game 1:</strong></p><ol><li>挑战者选择密钥$k \leftarrow \{0, 1\}^{n}$.</li><li>攻击者适应性地查询$Q = \{m_1, \cdots, m_q\}$ 对应的tag, 挑战者返回$\{t_1, \cdots, t_q\}$, 其中$t_i = f(m_i)$.</li><li>攻击者输出消息-tag对$(m, t)$, 若$t=f(m), m \notin Q$, 则攻击者成功。</li></ol><p>将攻击者在Game 1中成功的概率记为$S_1$.</p><p><strong>Claim 1</strong>: $Pr[S_1] = 2^{-n}$ .</p><p><strong>Proof of Claim 1:</strong> 显然当$m$从未被查询过时，$f(m)$的值为$\{0,1\}^{n}$上的随机元素，刚好取到$t$的概率为$2^{-n}$.</p><p><strong>Claim 2:</strong> $|Pr[S_0] - Pr[S_1]| \leq negl(n)$.</p><p><strong>Proof of Claim 2:</strong> 我们使用归约论证来证明该结论，假设攻击者$A$能成功伪造MAC, 我们构造新的算法D来区分真随机函数与伪随机函数。</p><p><strong>算法D:</strong></p><p>算法D的输入为$1^n$, 并且D能查询预言$O: \{0,1\}^n \rightarrow \{0,1\}^n$, 该算法的作用为区分$O$究竟是 真随机函数还是伪随机函数。</p><ol><li><p>运行$A(1^n)$, 当$A$用消息$m$来查询MAC预言时，如下回答：</p><p>(a)用$m$查询预言$O$, 返回值记为$t$, 将$t$值给$A$.</p></li><li><p>当$A$结束运行并输出$(m,t)$时：</p><p>(a)用$m$查询预言$O$, 返回$t’$.</p><p>(b)如果$t=t’$并且$A$之前从来没有查询过$m$, 则输出1, 反正输出0.</p></li></ol><p>显然，D是多项式时间算法。</p><p><strong>算法D的分析：</strong></p><p><strong>Case 1:</strong> 当$D$的预言$O$是伪随机函数时，攻击者$A$在Game 0中，此时$D$输出1当且仅当$A$在Game 0中成功，所以，</p><p>$Pr[D^{F_k(\cdot)}(1^n)=1]=Pr[S_0]$.</p><p><strong>Case 2:</strong> 当$D$的预言$O$是真随机函数时，攻击者$A$在Game 1中，此时$D$输出1当且仅当$A$在Game 1中成功，所以，</p><p>$Pr[D^{f(\cdot)}(1^n)=1]=Pr[S_1]$.</p><p>因为$F_k$为伪随机函数，所以我们有：</p><p>$|Pr[S_0]-Pr[S_1]| = |Pr[D^{F_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]|\leq negl(n)$.</p><p>Claim 2证明完毕。</p><p>结合Claim 1​和Claim 2我们有$|Pr[S_0]-2^{-n}| \leq negl(n)$, 即$Pr[S_0] \leq 2^{-n}+negl(n)$是可忽略的。</p><p>所以攻击者A成功伪造的概率可忽略，构造2.1是安全的MAC方案。</p><h2 id="2-2-任意消息长度的MAC方案"><a href="#2-2-任意消息长度的MAC方案" class="headerlink" title="2.2. 任意消息长度的MAC方案"></a>2.2. 任意消息长度的MAC方案</h2><p>假设$\Pi’=(Mac’, Vrfy’)$是定长的MAC方案，将$m$进行分块获得$m_1, \cdots, m_d$.</p><p><strong>思路1:</strong> 直接分块计算$t_i:=Mac_k^{‘}(m_i)$, 输出$<t_1,t_2,\cdots,t_d>$. 但这无法抵抗<strong>块重排序攻击</strong>，假设$(t_1, t_2)$为$(m_1, m_2)$对应的有效MAC. 则攻击者知道$(m_2, m_1)$对应的有效MAC是$(t_2,t_1)$.</t_1,t_2,\cdots,t_d></p><p><strong>思路2:</strong> 在每个块上加上块指数$i$, $t_i := Mac’_k(i||m_i)$, 这就能抵御<strong>块重排序攻击</strong>。但这无法抵御<strong>截断攻击</strong>，攻击者直接将最后一个区块去掉。比如$(t_1, t_2)$为$(m_1, m_2)$对应的有效MAC. 则攻击者知道$m_1$对应的有效MAC是$t_1$.</p><p><strong>思路3:</strong> 每个块上加上消息的长度$l$, $t_i:=Mac’_k(l||i||m_i)$, 这能抵御<strong>截断攻击</strong>，因为截断后长度改变。但这无法抵挡<strong>混淆攻击</strong>。比如攻击者已知$(m_1,m_2)$的MAC值为$(t_1,t_2)$, $(m’_1, m’_2)$的MAC值为$(t’_1,t’_2)$. 则攻击者能知道$(m_1, m’_2)$的MAC值为$(t_1, t’_2)$.</p><p><strong>Construction 2.3:</strong></p><p>假设$\Pi’=(Mac’, Vrfy’)$是固定长度$n$的MAC方案，则如下定义一个新的MAC：</p><ol><li><p>$Gen(1^n)$: 选择随机均匀密钥$k \leftarrow \{0,1\}^{n}$, 并输出。</p></li><li><p>$Mac(m, k)$: 输入的消息$m \in \{0,1\}^*$长度为$l &lt; 2^{n/4}$. 将 $m$ 分成 $d$ 个块$m_1, m_2, \cdots, m_d$, 每个块长度为$n/4$（最后的块用0补足）。选择随机标识符$r \in \{0,1\}^{n/4}$.</p><p>对于$i=1,2,\cdots,d$, 计算$t_i \leftarrow Mac’_k(r||l||i||m_i)$, $i, l$都用$n/4$长度的字符串来表示。输出标签$t=(r,t_1,t_2,\cdots, t_d)$.</p></li><li><p>$Vrfy(k,m,t)$: 输入标签$t = (r,t’_1, \cdots, t’_{d’})$，输入的消息$m \in \{0,1\}^*$长度为$l &lt; 2^{n/4}$. 将$m$分成$d$个块$m_1, m_2, \cdots, m_d$, 每个块长度为$n/4$（最后的块用0补足）。首先验证$d=d’$是否成立，其次对于$1\leq i \leq d$ 验证$t’_i=Mac’_k(r||l||i||m_i)$. 若验证均通过，输出1，反之输出0.</p></li></ol><p><strong>Theorem 2.4:</strong> 假设$\Pi’$为长度为$n$安全的定长MAC方案，那么上述构造是任意长度的安全MAC方案。</p><p> <strong>Proof:</strong> 假设$A$为概率多项式时间的攻击者，我们把$A$成功伪造上述MAC方案记为事件$S$, 我们要证明$Pr[S]$是可忽略的。</p><p>符号说明：</p><p>令$(m,t=<r,t_1,\cdots>)$为攻击者最后的输出，其中$m=m_1, \cdots$.</r,t_1,\cdots></p><p><strong>Repeat:</strong> 攻击者查询MAC预言得到的一系列tag值中，有两个随机标识符一样。</p><p><strong>NewBlock</strong>: 至少有一个块$r||l||i||m_i$在A的预言查询时从来未被$Mac’_k$认证过。</p><p>$Pr[S]=Pr[S \land Repeat]+Pr[S \land \overline{Repeat} \land NewBlock]+Pr[S \land \overline{Repeat} \land \overline{NewBlock}]$</p><p>$\leq Pr[Repeat]+Pr[S \land NewBlock]+Pr[S \land \overline{Repeat} \land \overline{NewBlock}]$</p><p>我们证明右边三个概率都是可忽略的。</p><p><strong>Claim 1:</strong> $Pr[Repeat]$是可忽略的。</p><p><strong>Proof of Claim 1</strong>: 令事件$H_{i,j}$为第$i$次查询和第$j$次查询选择的随机标识符一致。则由于标识符的长度为$2^{n/4}$, 我们有$Pr[H_{i,j}]=\frac{1}{2^{n/4}}$. 假设攻击者查询的次数为$q(n)$, $q$为某个多项式，那么</p><p>$Pr[Repeat] = Pr[\cup_{1 \leq i &lt; j \leq q(n)} H_{i,j}] = \sum_{i,j} Pr[H_{i,j}] = C_{q(n)}^2\frac{1}{2^{n/4}} \leq \frac{q(n)^2}{2^{n/4}}$</p><p>该值为可忽略的值。</p><p><strong>Claim 2:</strong> $Pr[S \land \overline{Repeat} \land \overline{NewBlock}]=0$</p><p>我们证明如果攻击者伪造成功且MAC查询时随机标识符都不相同，则<strong>NewBlock</strong>必然发生。</p><p><strong>Proof of Claim 2:</strong> 再次假设$q=q(n)$为攻击者进行MAC查询的次数。事件<strong>Repeat</strong>没有发生，则$r_1,r_2,…,r_q$各不相同。若$r \notin \{r_1,r_2,…,r_q\}$, 则显然<strong>NewBlock</strong>发生。</p><p>若存在$j$, 使得$r=r_j$, 假设$r_j$为攻击者第$j$次查询的标识符，对应的消息为$m^{(j)}$, 长度为$l_j$.</p><p><strong>Case 1:</strong> $l \neq l_j$, 则所有块的第二个分量都不一样，显然块$r||l||1||m_1$从未被查询过。<strong>NewBlock</strong>显然发生。</p><p><strong>Case 2:</strong> $l = l_j$, 则由于攻击者伪造成功了，我们有$m \neq m^{(j)}$. 假设$m$与$m^{(j)}$的第$i$个块不一致，即$m_i \neq m_i^{(j)}$. 那么显然$r||l||i||m_i$是新的块。<strong>NewBlock</strong>也发生。</p><p>综上所述，$S \land \overline{Reapeat}$ 发生则<strong>NewBlock</strong>一定发生。 $Pr[S \land \overline{Repeat} \land \overline{NewBlock}] = 0$.</p><p><strong>Claim 3:</strong> $Pr[S \land NewBlock]$是可忽略的。</p><p>我们用归约来证明Claim 3，假设有多项式时间攻击者$A$成功伪造MAC，我们构造新的多项式时间攻击者$A$来伪造方案$\Pi’$的MAC，这与我们的假设相反。</p><p><strong>Proof of Claim 3:</strong> </p><p>攻击者$A’$: 输入为$1^n$, 能用$Mac’_k(\cdot)$进行MAC预言查询。</p><p>​    把攻击者$A$当成子程序。</p><ol><li><p>当攻击者$A$用 $m$（长度为 $l$）进行$Mac_k(\cdot)$查询时:</p><p>(a)将$m$分成长度为$n/4$的块$m_1, m_2,…m_d$（假设有$d$个块），最后不够的用0补足。</p><p>(b)随机选择标识符$r \in \{0,1\}^{n/4}$, 对于$1 \leq i \leq d$, 用 $r||l||i||m_i$ 查询预言$Mac’_k(\cdot)$得到$t_i$.</p><p>(c)返回 $<r,t_1,...,t_d>$.</r,t_1,...,t_d></p><ol><li>当攻击者$A$输出伪造$(m, t = <r,t_1,...,t_d>$时，检查$NewBlock$是否发生：</r,t_1,...,t_d></li></ol><p>(a)若发生，假设$r||l||i||m_i$是新的块从未被认证过，则输出$<r||l||i||m_i, t_i>$.</r||l||i||m_i,></p><p>(b)若未发生，输出失败。</p></li></ol><p>显然，攻击者$A$作为$A’$的子程序时和在原始的攻击游戏中完全一致。</p><p>假设$NewBlock$ 发生，则块 $r||l||i||m_i$ 从来未被认证过。</p><p>假设$S$发生，攻击者$A$伪造成功，则所有块的tag值均有效，$t_i = Mac’_k(r||l||i||m_i)$. </p><p>所以如果$S \land NewBlock$发生，则攻击者$A’$成功伪造了$r||l||i||m$ 的MAC值。</p><p>假设攻击者$A’$成功的事件为$S’$, 我们有$Pr[S \land NewBlock] \leq Pr[S’]$. 根据我们的假设 $\Pi’$ 为安全的MAC方案，所以$Pr[S’]$可忽略，从而得到 $Pr[S \land NewBlock]$ 可忽略。</p><p>综合Claim 1,2,3, $Pr[S]$可忽略，该方案是安全的MAC方案。</p><h1 id="3-CBC-MAC"><a href="#3-CBC-MAC" class="headerlink" title="3. CBC-MAC"></a>3. CBC-MAC</h1><p>上一节构造的MAC方案效率低，比如计算消息长度为$dn$的MAC值，需要进行$4d$次分组计算，最后的tag长度为$4dn$. 本节给出更有效的构造。</p><h2 id="3-1-基本构造"><a href="#3-1-基本构造" class="headerlink" title="3.1. 基本构造"></a>3.1. 基本构造</h2><p><strong>Construction 3.1:</strong></p><p>假设$F$是伪随机函数，固定长度函数$l&gt;0$. 基本的CBC-MAC方案如下构造：</p><ol><li><p>$Gen(1^n)$: 随机选择$k \leftarrow \{0, 1\}^n$, 输出作为密钥。</p></li><li><p>$Mac(k, m)$: 输入消息的长度为$l(n) \cdot n$, 进行如下计算：</p><p>(a). 将$m$分成$m_1, m_2, … , m_l$, 每个$m_i$的长度为$n$.</p><p>(b). 令$t_0=0^n$, 对于$i$从1到$l$, 计算：</p><p>​        $t_i = F_k(t_{i-1} \oplus m_i)$.</p><p>(c). 输出$t_l$作为tag.</p></li><li><p>$Vrfy(t, m, k)$: 若$m$的长度不是$l(n) \cdot n$ 输出0，否则输出1当且仅当$t = Mac(k, m)$. </p></li></ol><p><strong>Theorem 3.2:</strong> 假设F是伪随机函数，$l$为多项式，则上述方案对于长度为$l(n) \cdot n$的消息来说是安全的MAC方案。</p><p>下一节证明一个更一般的结论。</p><h2 id="3-2-安全性证明"><a href="#3-2-安全性证明" class="headerlink" title="*3.2. 安全性证明"></a>*3.2. 安全性证明</h2><p><strong>本节稍有难度，可以选择跳过不影响后面学习。</strong></p><p>定义CBC函数，输入为$(\{0,1\}^n)^*$中的元素（也就是长度为n的倍数）以及长度为n的密钥映射到长度为n的字符串。</p><p>$CBC_k(x_1,…,x_l)=F_k(F_k( \cdots F_k(F_k(x_1) \oplus x_2) \oplus \cdots ) \oplus x_l)$.</p><p>$|x_1|=|x_2|=\cdots=|x_l|=|k|=n$.</p><p>一个字符串集合$P \subset (\{0,1\}^n)^*$是无前缀的如果它不包含空串以及任何字符串 $X \in P$ 都不是其它字符串 $X’ \in P$ 的前缀。</p><p><strong>Theorem 3.3:</strong> 对于任意的概率多项式时间算法$D$, $D$ 能进行预言查询，但所有查询的字符串构成的集合是无前缀的。存在可忽略的函数$negl$, 使得，</p><p>$|Pr[D^{CBC_k(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]| \leq negl(n)$.</p><p>我们可以用一个编码函数$encode$, 将任意长度的字符串$m$映射到 $encode(m) \in (\{0,1\}^n)^*$, 然后输出$CBC_k(encode(m))$. 该编码方案需要是无前缀的。</p><p>我们证明当CBC的“密钥”是一个随机函数$g$时的安全性，也就是说定义</p><p>$CBC_g(x_1,…,x_l)=g(g( \cdots g(g(x_1) \oplus x_2) \oplus \cdots ) \oplus x_l)$.</p><p>我们证明$CBC_g(\cdot)$与$(\{0,1\}^n)^*$到$\{0,1\}^n$上的随机函数就是不可区分。</p><p><strong>Theorem 3.4:</strong> 固定$n \geq 1$, 取随机函数$g:\{0,1\}^n \rightarrow \{0, 1\}^n, f:$$(\{0,1\}^n)^* \rightarrow \{0,1\}^n$, 对于任意（无时间限制）算法$D$, $D$ 能进行$q$次预言查询，但这$q$次查询的字符串构成的集合是无前缀的，并且所有的查询中最长的消息包含$l$个区块。则</p><p>$|Pr[D^{CBC_g(\cdot)}(1^n)=1]-Pr[D^{f(\cdot)}(1^n)=1]| \leq \frac{q^2 l^2}{2^n}$.</p><p><strong>Proof of Theorem 3.4:</strong> 假设$P=\{X_1,…,X_q\}$为无前缀的q次查询，每个$X_i \in (\{0, 1\}^n)^*$, 且$P$中最长的消息包含$l$个区块。对于任意的$t_1,…,t_q \in \{0,1\}^n$, 有$Pr[\forall i:f(X_i)=t_i] = 2^{-nq}$.</p><p>我们称CBC是$(q,l,\delta)-smooth$的如果对于每个无前缀集合$P=\{X_1,…,X_q\}$,  以及每个$t_1,…,t_q \in \{0,1\}^n$ ,有</p><p>$Pr[\forall i: CBC_g(X_i)=t_i] \geq (1-\delta) \cdot 2^{-nq}$.</p><p>也就是说 $(q,l,\delta)-smooth$ 的CBC是 $\delta-close$ 真随机函数 $f$ 的。</p><p><strong>Claim 3.5:</strong> $CBC_g$是$(q,l,\delta)-smooth$的，其中 $\delta = q^2l^2 \cdot 2^{-n}$.</p><p><strong>下面假设Claim 3.5成立。</strong></p><p>定义函数$\alpha(X_1,…,X_q;t_1,…, tq) = 1$当且仅当$D$查询$X_1,…,X_q$时返回$t_1,…,t_q$, 且$D$最后输出1.</p><p>令$\overrightarrow{X} = \{X_1,…,X_q\}$, $\overrightarrow{t} = \{t_1,…,t_q\}$, 我们有</p><p>$\operatorname{Pr}\left[D^{\mathrm{CBC}_{g}(\cdot)}\left(1^{n}\right)=1\right]$</p><p>$=\sum_{\vec{X} \text { prefix-free; } \vec{t}} \alpha(\vec{X}, \vec{t}) \cdot \operatorname{Pr}\left[\forall i : \mathrm{CBC}_{g}\left(X_{i}\right)=t_{i}\right]$</p><p>$\geq \sum_{\vec{X} \text { prefix-free; } \vec{t}} \alpha(\vec{X}, \vec{t}) \cdot(1-\delta) \cdot \operatorname{Pr}\left[\forall i : f\left(X_{i}\right)=t_{i}\right]$</p><p>$=(1-\delta) \cdot \operatorname{Pr}\left[D^{f(\cdot)}\left(1^{n}\right)=1\right]$,</p><p>这证明了</p><p>$\operatorname{Pr}\left[D^{f(\cdot)}\left(1^{n}\right)=1\right]-\operatorname{Pr}\left[D^{\mathrm{CBC}_{g}(\cdot)}\left(1^{n}\right)=1\right] \leq \delta \cdot \operatorname{Pr}\left[D^{f(\cdot)}\left(1^{n}\right)=1\right] \leq \delta$.</p><p>完成<strong>Theorem 3.4</strong>的证明。</p><p>下面进行Claim 3.5的证明。</p><p><strong>Proof of Claim 3.5:</strong> </p><p>令$X \in\left(\{0,1\}^{n}\right)^{*}$, 且$X=x_1,…$并且$, |x_i|=n$.</p><p>令$C_g(x)$是 计算$CBC_g(X)$过程中$g$的输入构成的集合。例如假设$X \in\left(\{0,1\}^{n}\right)^{m}$, 那么</p><p>$\mathcal{C}_{g}(X) \stackrel{\mathrm{def}}{=}\left(x_{1}, \mathrm{CBC}_{g}\left(x_{1}\right) \oplus x_{2}, \ldots, \mathrm{CBC}_{g}\left(x_{1}, \ldots, x_{m-1}\right) \oplus x_{m}\right)$.</p><p>令$X \in\left(\{0,1\}^{n}\right)^{m}$, $X’ \in\left(\{0,1\}^{n}\right)^{m’}$.</p><p>$C_g(X)=(I_1,…,I_m), C_g(X’)=(I’_1,…,I’_{m’})$.</p><p>称$X$内部存在非平凡碰撞如果存在 $I_i=I_j$ 但是 $i \neq j$.</p><p>称$X,X’$之间存在非平凡碰撞如果存在 $I_i = I’_j$ 但是$\left(x_{1}, \ldots, x_{i}\right) \neq\left(x_{1}^{\prime}, \ldots, x_{j}^{\prime}\right)$.</p><p>称字符串集合$P=\{X_1,…,X_q\}$ 存在非平凡碰撞若存在 $X \in P$ 有内部碰撞或者存在$X,X’ \in P$之间存在碰撞。</p><p>定义事件 $Coll$ 为集合P存在非平凡碰撞。</p><p>我们分两部来完成证明：</p><p>第一步：如果 $Coll$ 未发生，则 $\operatorname{Pr}\left[\forall i : \operatorname{CBC}_{g}\left(X_{i}\right)=t_{i} | \overline{\mathrm{Coll}}\right]=2^{-n q}$.</p><p>第二步：证明 $Coll$ 发生的概率小于$\delta \leq q^2l^2\cdot 2^{-n}$.</p><p>对于$X$, 随机均匀选择 $g(I_1)$ 的值，确定$I_2=g(I_1) \oplus x_2$, 随机均匀选择$g(I_2)$的值，如此重复，直到选择 $g(I_{m-1})$ 的随机值（无需选取$g(I_m)$的值，因为$g(I_m) \notin C_g(X)$）。用上述方式计算出字符串$X_1,…,X_q$对应的$C_g(X_1),…,C_g(X_q)$，然后就可检查事件 $Coll$ 是否发生。</p><p>假设事件$Coll$未发生，那么$C_g(X_1),…,C_g(X_q)$中的最后一项必不相同。我们证明$g$在这些最后一项上的值未被确定，假设$C_g(X)$的最后一项$I_m$的$g$值已经被确定，那么肯定存在$I’_j$, $I_m = I’_j$并且 $I’_j$ 不是$C_g(X’)$的最后一项。但是由于事件$Coll$未发生，上述事件只有当$(x_1,…,x_m) = (x’_1,…,x’_j)$发生时才发生，但由于$X \neq X’$, 我们得到$X$是$X’$的前缀，这与$P$无前缀相矛盾。</p><p>$CBC_g(X_i)$的值就是$g$在$C_g(X_i)$上最后一项的值。根据上述分析，$g$在最后一项上的值未被确定，所以从$\{0,1\}^n$上独立均匀选出，选择到某个固定值的概率为$2^{-n}$. 选择任意的$t_1,…,t_q \in \{0,1\}^n$, 有</p><p>$\operatorname{Pr}\left[\forall i : \operatorname{CBC}_{g}\left(X_{i}\right)=t_{i} | \overline{\mathrm{Coll}}\right]=2^{-n q}$.</p><p>第一步证明完毕，下面进行第二步证明。</p><p>给定$X_i, X_j \in P$, 令$Coll_{i,j}$为$X_i, X_j$中内部存在碰撞或者$X_i,X_j$之间存在碰撞，则</p><p>$Coll =\lor_{i, j} \text { Coll }_{i, j}$,</p><p>$\operatorname{Pr}[\mathrm{Coll}] \leq \sum_{i, j : i&lt;j} \operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right]=\left(\begin{array}{c}{q} \ {2}\end{array}\right) \cdot \operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right] \leq \frac{q^{2}}{2} \cdot \operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right]$.</p><p>令$X=X_i, X’=X_j$, 两者的块长度都是$l$. $X=(x_1,…,x_l), X’=(x’_1,…,x’_l)$, $t$是最大的整数使得</p><p>$(x_1,…,x_t)=(x’_1,…,x’_t)$.（其中 $t &lt; l$ 否则 $X=X’$）</p><p>注意到此时$(I_1,…,I_t) = (I’_1,…,I’_t)$.</p><p>用下面 $2l-t-2$ 步来确定 $g$ 的值：</p><p>$i$ 从1到 $t-1$ :</p><p>​    随机均匀选择$g(I_i)$的值从而确定 $I_{i+1}$和$I’_{i+1}$.（注意这步两者相等）</p><p> $i = t$ :</p><p>​    随机均匀选择$g(I_t)$的值从而确定 $I_{t+1}$和$I’_{t+1}$.（注意这步两者不等）</p><p> $i$ 从 $t+1$ 到 $l-1$:</p><p>​    随机均匀选择 $g(I_{t+1}),g(I_{t+2}),…,g(I_{l-1})$ 的值从而确定 $I_{t+2}, I_{t+3},…,I_{l}$.</p><p>$i$ 从 $l$ 到 $2l-t-2$:</p><p>​    随机均匀选择 $g(I’_{t+1}),g(I’_{t+2}),…,g(I’_{l-1})$ 的值从而确定 $I’_{t+2}, I’_{t+3},…,I’_{l}$.</p><p>假设事件$Coll(k)$表示第$k$步发生了非平凡碰撞，那么</p><p>$\operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right]=\operatorname{Pr}\left[\lor_{k} \operatorname{Coll}(k)\right] \leq \operatorname{Pr}[\operatorname{Coll}(1)]+\sum_{k=2}^{2l-t-2} \operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}]$.</p><p>若 $k&lt;t$, $Coll(k-1)$未发生，则$(I_1,..,I_k)$各不相同，$I_{k+1}=g(I_k) \oplus x_{k+1}$与前$k$个值发生碰撞的概率为$\frac{k}{2^n}$, 所以$\operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}]=k / 2^{n}$.</p><p>若 $k=t$, $\operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}] \leq 2t / 2^{n}$, 因为这一步生成了两个值$I_{t+1}, I’_{t+1}$且不相同。</p><p>若 $k &gt; t$, $\operatorname{Pr}[\operatorname{Coll}(k) | \overline{\operatorname{Coll}(k-1)}] \leq (k+1) / 2^{n}$, 因为第$t$步多生成了一个值，所以加上1.</p><p>我们得出</p><p>$\operatorname{Pr}\left[\mathrm{Coll}_{i, j}\right] \leq 2^{-n} \cdot\left(\sum_{k=1}^{t-1} k+2 t+\sum_{k=t+1}^{2l-t-2}(k+1)\right) $</p><p>$= 2^{-n} \cdot \sum_{k=2}^{2l-t-1} k=2^{-n} \cdot(2 l - t+1) \cdot(2l - t-2)/2 &lt; 2 \ell^{2} \cdot 2^{-n}$.</p><p>所以，我们有</p><p>$Pr[Coll] \leq \frac{q^2}{2}Pr[Coll_{i,j}] &lt; q^2l^2 \cdot 2^{-n} = \delta$.</p><p>综合所有，我们有</p><p>$Pr[\forall i: CBC_g(X_i)=t_i] \geq Pr[\forall i: CBC_g(X_i)=t_i|\overline{Coll}] \cdot Pr[\overline{Coll}] \geq 2^{-nq}\cdot Pr[\overline{Coll}] \geq (1-\delta)\cdot2^{-nq}$.</p><p>这就证明了 $CBC_g$ 是$(q,l,\delta)-smooth$的。</p><h1 id="4-认证加密"><a href="#4-认证加密" class="headerlink" title="4. 认证加密"></a>4. 认证加密</h1><p>如何设计加密方案使其既保证安全性又保证消息的完整性？</p><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1. 定义"></a>4.1. 定义</h2><p>我们规定密文必须满足某种条件，攻击者无法伪造出有效的密文。</p><p>考虑攻击者与挑战者$A$之间不可伪造的加密游戏：</p><ol><li>挑战者运行$Gen(1^n)$获得私钥$k$.</li><li>攻击者$A$输入$1^n$以及可以用消息$m_i$进行加密查询，挑战者计算$c_i=Enc_k(m_i)$并返回。</li><li>攻击者$A$最后输出一段密文$c$.</li><li>令$Q$表示攻击者进行的加密查询集合，挑战者计算$m=Dec_k(c)$, 若密文无效输出$\perp$.攻击者在该游戏中成功当且仅当$m \neq \perp$且$m \notin Q$.</li></ol><p>把上述攻击者成功的事件记为事件$S$.</p><p><strong>定义4.1: </strong>我们称一个对称加密方案 $\Pi$ 是不可伪造的，如果对于任意的概率多项式时间攻击者，存在一个可忽略的函数 $negl$ 使得$Pr[S] \leq negl(n)$.</p><p><strong>定义4.2:</strong> 如果一个加密方案是CCA安全并且不可伪造的，那么称该方案是一个认证加密。</p><h2 id="4-2-通用构造"><a href="#4-2-通用构造" class="headerlink" title="4.2. 通用构造"></a>4.2. 通用构造</h2><p>假设$\Pi_E=(Enc,Dec)$为CPA安全的加密方案，$\Pi_M=(Mac, Vrfy)$ 为MAC方案，$k_E, k_M$为对应方案的密钥。考虑下面三种方案：</p><ol><li><strong>加密并认证：</strong>密文为$<c,t>$, 其中$c \leftarrow Enc_{k_E}(m), t \leftarrow Mac_{k_M}(m)$. 接收者先解密得到$m$, 再验证$Vrfy(m,t)=1$是否成立，若成立，输出$m$, 反之输出错误。</c,t></li><li><strong>先认证，再加密：</strong>密文为$c$, 先计算$t \leftarrow Mac_{k_M}(m)$, 再计算$c \leftarrow Enc_{k_E}(m||t)$. 接收者先解密得到$m||t$, 再验证$Vrfy(m,t)=1$是否成立，若成立，输出$m$, 反之输出错误。</li><li><strong>先加密，再认证：</strong>密文为$<c,t>$, 先计算$c \leftarrow Enc_{k_E}(m)$, 再计算$t \leftarrow Mac_{k_M}(c)$, 接收者先验证$Vrfy(c,t)=1$是否成立，若成立解密出$m$, 反之输出错误。</c,t></li></ol><p>注意MAC方案不保证不泄露原文的一些消息，所以直接计算明文的MAC值并作为密文的一部分并不安全，方案1，2不适用。</p><p>考虑第3种方案，先加密，后认证：</p><p><strong>Construction 4.3:</strong> </p><p>假设$\Pi_E=(Enc,Dec)$为私钥加密方案，$\Pi_M=(Mac, Vrfy)$ 为消息认证编码。定义如下的私钥加密方案：</p><ol><li>$Gen’$: 随机均匀选择密钥$k_E, k_M \in \{0,1\}^n$.</li><li>$Enc’$: 输入消息$m$以及密钥$k_E, k_M$, 计算$c \leftarrow Enc_{k_E}(m)$, 再计算$t \leftarrow Mac_{k_M}(c)$, 输出密文$<c,t>$.</c,t></li><li>$Dec’$: 输入密文$<c,t>$, 密钥$k_E, k_M$, 首先验证$Vrfy(c, t)=1$是否成立，若成立，输出$m=Dec_{k_E}(c)$, 反之输出$\perp$.</c,t></li></ol><p><strong>Theorem 4.4:</strong> 假设$\Pi_E$为CPA安全的私钥加密方案，$\Pi_M$是安全的消息认证编码，则上述构造为一个认证加密方案。</p><p><strong>Proof of Theorem 4.4:</strong> 非形式化地说，由于密文包含 $c$ 的MAC值，而由于我们假设$\Pi_M$是不可伪造的MAC方案，所以攻击者无法伪造出$c$的MAC值，也就是说无法伪造出有效的密文。这就说明了该方案是不可伪造的方案。并且由于密文不可伪造性，攻击者进行解密查询的密文都是无效的（有可忽略的概率可能有效），解密预言返回$\perp$, 所以解密预言并没有给攻击者额外的帮助，所以若 $\Pi_E$ 是CPA安全的话，该方案是CCA安全的。</p><p>假设$A$是概率多项式时间的攻击者在CCA-Game中攻击构造4.3.</p><p>称密文$<c,t>$是新的如果$A$没从加密预言中获得过$<c,t>$.</c,t></c,t></p><p>定义事件$ValidQuery$为$A$提交给解密预言的密文是新的且是有效的，$Vrfy(c,t)=1$.</p><p><strong>Claim 4.5:</strong> $Pr[ValidQuery]$是可以忽略的。</p><p><strong>Proof of Claim 4.5:</strong> 令$q(n)$为攻击者$A$进行解密查询的次数，我们构造新的攻击者$A_M$, 把$A$作为子程序调用，在MAC伪造Game中攻击MAC方案$\Pi_M$.</p><p>攻击者$A_M$: 输入$1^n$, 允许其能进行MAC预言查询$Mac_{k_M}(\cdot)$.</p><ol><li><p>$k_E \leftarrow \{0,1\}^n, i \in \{1,2,…,q(n)\}$.</p></li><li><p>当$A$用$m$进行加密查询时：</p><p>(1). $c \leftarrow Enc_{k_E}(m)$,</p><p>(2). 用$c$进行MAC预言查询，获得$c \leftarrow Mac_{k_M}(\cdot)$. 将$<c,t>$返回给$A$.</c,t></p><p>(3). 用同样的方式生成挑战密文。</p></li><li><p>当$A$用$<c,t>$进行解密查询时，若这恰好是第$i$次查询，$A_M$直接输出$<c,t>$, 否则：</c,t></c,t></p><p>(1). 若$<c,t>$是之前$A$用$m$加密查询生成的，直接返回$m$.</c,t></p><p>(2). 否则输出$\perp$.</p></li></ol><p>显然$A_E$是概率多项式时间算法。</p><p>直观上看，$A_M$预测$A$第$i$次查询 $<c,t>$ 是新的且有效的查询。则 $<c,t>$ 从未被$A_M$查询过，$A_M$ 成功伪造了$c$ 的MAC值$t$. </c,t></c,t></p><p>令事件$S_M$为$A_M$成功伪造了$MAC$值。$A$进行新且有效查询的概率为$Pr[ValidQuery]$, 该查询恰好是第$i$次查询的概率为$Pr[ValidQuery]/q(n)$. 所以$Pr[S_M] = Pr[ValidQuery]/q(n)$. 而我们假设 $\Pi_M$ 是安全的MAC方案，所以$Pr[S_M]$是可忽略的，而又$q(n)$是多项式，所以$Pr[ValidQuery]$ 也是可忽略的。</p><p>下面证构造3.5 $\Pi’$ 是密文不可伪造的。</p><p>假设攻击者 $A’$ 能对方案 $\Pi’$ 进行密文伪造，$A$将$A’$作为子程序调用，当$A’$成功伪造$<c,t>$时，$A$ 用 $<c,t>$进行密文查询。但是我们已经证明$A$进行有效密文查询的概率可忽略，所以$A’$伪造成功的概率也可忽略，所以 $\Pi’$ 是不可伪造的加密方案。</c,t></c,t></p><p>下面证$\Pi’$ 是CCA安全的。</p><p>令事件 $S$ 为攻击者$A$在CCA游戏中成功击破了方案$\Pi’$.</p><p>$Pr[S] = Pr[S \land ValidQuery]+Pr[S \land \overline{ValidQuery}] \leq Pr[ValidQuery] + Pr[S \land \overline{ValidQuery}]$.</p><p>已知$Pr[ValidQuery]$可忽略，所以只要证明如下Claim.</p><p><strong>Claim 4.6:</strong> $Pr[S \land \overline{ValidQuery}] \leq \frac{1}{2}+negl(n)$.</p><p><strong>Proof of Claim 4.6:</strong> 直观上看由于$ValidQuery$事件未发生，所有解密查询都是无效的，解密预言未提供任何额外能力，所以如果$\Pi_E$是CPA安全的话，$\Pi’$也是CCA安全的。</p><p>我们构造攻击者$A_E$在CPA-Game中攻击方案$\Pi_E$.</p><p>攻击者$A_E$: 输入为$1^n$, 能进行加密查询$Enc_{k_E}(\cdot)$.</p><ol><li><p>$k_M \leftarrow \{0,1\}^n$.</p></li><li><p>当$A$用消息$m$进行加密查询时，</p><p>(1). 用$m$进行加密查询$Enc_{k_E}(\cdot)$, 获得$c \leftarrow Enc_{k_E}(\cdot)$.</p><p>(2). 计算$t \leftarrow Mac_{k_M}(c)$, 将$<c,t>$返回给$A$.</c,t></p></li><li><p>当$A$用$<c,t>$进行解密查询时，</c,t></p><p>(1). 若$<c,t>$是之前消息$m$加密查询的返回值，直接输出$m$.</c,t></p><p>(2). 反之，输出$\perp$.</p></li><li><p>$A$提交两段等长明文$m_0, m_1$, </p><p>(1). $A_E$ 将这两段明文提交给自己的挑战者得到挑战密文$c$.</p><p>(2). 计算$t \leftarrow Mac_{k_M}(c)$, 将$<c,t>$作为$A$的挑战密文.</c,t></p></li><li><p>当$A$输出1个bit后，$A_E$ 输出相同的bit.</p></li></ol><p>显然，$A_E$是概率多项式时间的算法。</p><p>当事件$ValidQuery$未发生时，$A$作为$A_E$的子程序与在原始的CCA-Game中完全一致。</p><p>令事件$S_E$为$A_E$在CPA-Game中成功。从上述算法中我们可得，$A_E$成功当且仅当$A$成功，所以</p><p>$Pr[S_E \land \overline{ValidQuery}] = Pr[S \land \overline{ValidQuery}]$.</p><p>我们得出</p><p>$Pr[S_E] \geq Pr[S_E \land \overline{ValidQuery}] = Pr[S \land \overline{ValidQuery}]$</p><p>又 $\Pi_E$ 是CPA安全的，$Pr[S_E] \leq 1/2 + negl(n)$. 所以$Pr[S \land \overline{ValidQuery}] \leq \frac{1}{2}+negl(n)$.</p><p>所以，$Pr[S] \leq Pr[ValidQuery] + Pr[S \land \overline{ValidQuery}] \leq 1/2 + negl’(n)$.</p><p>$\Pi’ $ 是CCA安全的方案。</p><p>综上$\Pi’$是安全的认证加密方案。</p><h2 id="4-3-CCA安全加密"><a href="#4-3-CCA安全加密" class="headerlink" title="4.3. CCA安全加密"></a>4.3. CCA安全加密</h2><p>可伪造与CCA安全不等价，存在可伪造但还是CCA安全的方案。</p><p>认证加密与CCA安全其实也不等价，CCA安全方案与认证加密目的不同，认证加密我们要求的是消息的完整性与安全性，CCA安全不考虑消息的完整性，只考虑能进行解密查询的敌手。在公钥加密体制中，CCA安全方案与认证加密的区别较大。</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息认证编码 </tag>
            
            <tag> 认证加密 </tag>
            
            <tag> CCA安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/12/08/hello-world/"/>
      <url>/2020/12/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
