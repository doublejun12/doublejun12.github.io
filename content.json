{"meta":{"title":"SJ Zhang's Blog","subtitle":"MyBlog","description":"Fudan University","author":"Shuangjun Zhang","url":"https://doublejun12.github.io","root":"/"},"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"404.html","permalink":"https://doublejun12.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"about/index.html","permalink":"https://doublejun12.github.io/about/index.html","excerpt":"","text":"教育经历 硕士 计算机科学与技术华东师范大学2018/06 - 现在 本科 计算机科学与技术华东师范大学2014/09 - 2018/06综合排名专业第一 获得荣誉2017 金牌ACM-ICPC全国邀请赛（陕西） 特等奖学金大三学年 二等奖蓝桥杯C++组（上海） 团体一等奖中国高校计算机大赛-团体程序设计天梯赛 高校一等奖中国高校计算机大赛-团体程序设计天梯赛 2016 银牌ACM-ICPC亚洲区域赛（青岛） 铜牌ACM-CCPC总决赛（宁波） 铜牌ACM-CCPC（杭州） 一等奖学金大二学年 2015 国家奖学金大一学年 铜牌ACM-ICPC亚洲区域赛（上海） 铜牌ACM-ICPC上海大都会赛 联系方式 电子邮箱godweiyang@gmail.comi@godweiyang.com792321264@qq.com 地址上海市普陀区中山北路3663号理科大楼B906，邮编200062 QQ 技术交流群864832264"},{"title":"categories","date":"2019-07-19T08:39:20.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"categories/index.html","permalink":"https://doublejun12.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-07-19T08:39:20.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"archives/index.html","permalink":"https://doublejun12.github.io/archives/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-19T08:42:10.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"friends/index.html","permalink":"https://doublejun12.github.io/friends/index.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：godweiyang 地址：https://godweiyang.com 简介：公众号【算法码上来】，分享深度学习与NLP算法 头像：https://godweiyang.com/medias/avatars/avatar.jpg"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"tags/index.html","permalink":"https://doublejun12.github.io/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2019-07-26T09:17:02.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"contact/index.html","permalink":"https://doublejun12.github.io/contact/index.html","excerpt":"","text":"欢迎留言大家有任何问题，都可以在评论区给我留言，或者加 QQ 技术交流群【群号：864832264】。 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：godweiyang 地址：https://godweiyang.com 简介：公众号【算法码上来】，分享深度学习与NLP算法 头像：https://godweiyang.com/medias/avatars/avatar.jpg"}],"posts":[{"title":"TEST","slug":"TEST-0","date":"2020-12-07T18:58:50.000Z","updated":"2020-12-07T18:59:15.845Z","comments":true,"path":"2020/12/08/test-0/","link":"","permalink":"https://doublejun12.github.io/2020/12/08/test-0/","excerpt":"","text":"ZSJ沃拉普","categories":[],"tags":[]},{"title":"","slug":"Test","date":"2020-12-07T18:57:57.695Z","updated":"2020-12-07T18:57:57.695Z","comments":true,"path":"2020/12/08/test/","link":"","permalink":"https://doublejun12.github.io/2020/12/08/test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TCS","slug":"TCS","date":"2020-12-07T16:58:29.000Z","updated":"2020-12-07T18:49:17.294Z","comments":true,"path":"2020/12/08/tcs/","link":"","permalink":"https://doublejun12.github.io/2020/12/08/tcs/","excerpt":"","text":"$$5\\cdot(1+4+1)$$My name isZSJ","categories":[],"tags":[]},{"title":"Hello World张双俊","slug":"hello-world","date":"2020-12-07T16:38:37.555Z","updated":"2020-12-07T18:56:22.708Z","comments":true,"path":"2020/12/08/hello-world/","link":"","permalink":"https://doublejun12.github.io/2020/12/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.在实践中时间 Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"十大经典排序算法整理汇总（附代码）","slug":"sort-algorithms","date":"2020-02-16T07:09:23.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"2020/02/16/sort-algorithms/","link":"","permalink":"https://doublejun12.github.io/2020/02/16/sort-algorithms/","excerpt":"","text":"关注公众号【算法码上来】，每日算法干货马上就来！ 前言本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。 本文并不会详细讲解每种排序算法的原理，网上有很多很好的教程，大家可以自己去搜了看。 最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 LeetCode 912. 排序数组 这道题。 性质汇总 如果发现表中有错误，请留言告知。 算法 最好 最坏 平均 空间 稳定性 是否基于比较 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\checkmark$ $\\checkmark$ 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\times$ $\\checkmark$ 插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\checkmark$ $\\checkmark$ 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$~$O(n)$ $\\times$ $\\checkmark$ 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ $\\checkmark$ $\\checkmark$ 希尔排序 $O(n^{1.3})$ $O(n^2)$ $O(n\\log n)$~$O(n^2)$ $O(1)$ $\\times$ $\\checkmark$ 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ $\\checkmark$ $\\times$ 基数排序 $O(nk)$ $O(nk)$ $O(nk)$ $O(n+k)$ $\\checkmark$ $\\times$ 桶排序 $O(n)$ $O(n)$ $O(n)$ $O(n+m)$ $\\checkmark$ $\\times$ 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ $\\times$ $\\checkmark$ 如果表格显示有问题的话，还可以直接看下面的汇总图： 维基百科我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。 冒泡排序https://en.wikipedia.org/wiki/Bubble_sort 选择排序https://en.wikipedia.org/wiki/Selection_sort 插入排序https://en.wikipedia.org/wiki/Insertion_sort 快速排序https://en.wikipedia.org/wiki/Quicksort 归并排序https://en.wikipedia.org/wiki/Merge_sort 希尔排序https://en.wikipedia.org/wiki/Shellsort 计数排序https://en.wikipedia.org/wiki/Counting_sort 基数排序https://en.wikipedia.org/wiki/Radix_sort 桶排序https://en.wikipedia.org/wiki/Bucket_sort 堆排序https://en.wikipedia.org/wiki/Heapsort 代码实现所有的排序算法接口都是相同的，也就是 vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums) 。只需要你传入一个 vector&lt;int&gt; 类型的数组，就能返回排序后的结果。 运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。 class Solution { public: vector&lt;int> sortArray(vector&lt;int>&amp; nums) { return quickSort(nums); } // 冒泡排序（超时） vector&lt;int> bubbleSort(vector&lt;int>&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { for (int j = n-2; j >= i; --j) { if (nums[j] > nums[j+1]) { swap(nums[j], nums[j+1]); } } } return nums; } // 选择排序（超时） vector&lt;int> selectSort(vector&lt;int>&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { int idx = i; for (int j = i; j &lt; n; ++j) { if (nums[j] &lt; nums[idx]) { idx = j; } } swap(nums[i], nums[idx]); } return nums; } // 插入排序（超时） vector&lt;int> insertSort(vector&lt;int>&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { for (int j = i; j > 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) { swap(nums[j], nums[j-1]); } } return nums; } // 快速排序（24 ms） void qSort(vector&lt;int>&amp; nums, int l, int r) { if (l >= r) return; int m = l; for (int i = l; i &lt; r; ++i) { if (nums[i] &lt; nums[r]) { swap(nums[m++], nums[i]); } } swap(nums[m], nums[r]); qSort(nums, l, m-1); qSort(nums, m+1, r); } vector&lt;int> quickSort(vector&lt;int>&amp; nums) { int n = nums.size(); qSort(nums, 0, n-1); return nums; } // 归并排序（192 ms） vector&lt;int> mSort(vector&lt;int>&amp; nums, int l, int r) { if (l >= r) return {nums[l]}; int m = l+(r-l)/2; vector&lt;int> lnums = mSort(nums, l, m); vector&lt;int> rnums = mSort(nums, m+1, r); vector&lt;int> res; int i = 0, j = 0; while (i &lt;= m-l &amp;&amp; j &lt;= r-m-1) { if (lnums[i] &lt; rnums[j]) { res.push_back(lnums[i++]); } else { res.push_back(rnums[j++]); } } while (i &lt;= m-l) { res.push_back(lnums[i++]); } while (j &lt;= r-m-1) { res.push_back(rnums[j++]); } return res; } vector&lt;int> mergeSort(vector&lt;int>&amp; nums) { int n = nums.size(); nums = mSort(nums, 0, n-1); return nums; } // 归并排序 + 非递归（80 ms） vector&lt;int> mergeSortNR(vector&lt;int>&amp; nums) { int n = nums.size(); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { for (int l = 0; l &lt; n-len; l += 2*len) { int m = l+len-1; int r = min(n-1, l+2*len-1); vector&lt;int> res; int i = l, j = m+1; while (i &lt;= m &amp;&amp; j &lt;= r) { if (nums[i] &lt; nums[j]) { res.push_back(nums[i++]); } else { res.push_back(nums[j++]); } } while (i &lt;= m) { res.push_back(nums[i++]); } while (j &lt;= r) { res.push_back(nums[j++]); } for (int i = l; i &lt;= r; ++i) { nums[i] = res[i-l]; } } } return nums; } // 希尔排序（40 ms） vector&lt;int> shellSort(vector&lt;int>&amp; nums) { int n = nums.size(); for (int gap = n/2; gap > 0; gap /= 2) { for (int i = gap; i &lt; n; ++i) { for (int j = i; j-gap >= 0 &amp;&amp; nums[j-gap] > nums[j]; j -= gap) { swap(nums[j-gap], nums[j]); } } } return nums; } // 计数排序（32 ms） vector&lt;int> countSort(vector&lt;int>&amp; nums) { int n = nums.size(); if (!n) return {}; int minv = *min_element(nums.begin(), nums.end()); int maxv = *max_element(nums.begin(), nums.end()); int m = maxv-minv+1; vector&lt;int> count(m, 0); for (int i = 0; i &lt; n; ++i) { count[nums[i]-minv]++; } vector&lt;int> res; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; count[i]; ++j) { res.push_back(i+minv); } } return res; } // 基数排序（不适用于负数） vector&lt;int> radixSort(vector&lt;int>&amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(), nums.end()); int maxd = 0; while (maxv > 0) { maxv /= 10; maxd++; } vector&lt;int> count(10, 0), rank(n, 0); int base = 1; while (maxd > 0) { count.assign(10, 0); for (int i = 0; i &lt; n; ++i) { count[(nums[i]/base)%10]++; } for (int i = 1; i &lt; 10; ++i) { count[i] += count[i-1]; } for (int i = n-1; i >= 0; --i) { rank[--count[(nums[i]/base)%10]] = nums[i]; } for (int i = 0; i &lt; n; ++i) { nums[i] = rank[i]; } maxd--; base *= 10; } return nums; } // 桶排序 (20 ms) vector&lt;int> bucketSort(vector&lt;int>&amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(), nums.end()); int minv = *min_element(nums.begin(), nums.end()); int bs = 1000; int m = (maxv-minv)/bs+1; vector&lt;vector&lt;int> > bucket(m); for (int i = 0; i &lt; n; ++i) { bucket[(nums[i]-minv)/bs].push_back(nums[i]); } int idx = 0; for (int i = 0; i &lt; m; ++i) { int sz = bucket[i].size(); bucket[i] = quickSort(bucket[i]); for (int j = 0; j &lt; sz; ++j) { nums[idx++] = bucket[i][j]; } } return nums; } // 堆排序（32 ms） void adjust(vector&lt;int>&amp; nums, int p, int s) { while (2*p+1 &lt; s) { int c1 = 2*p+1; int c2 = 2*p+2; int c = (c2&lt;s &amp;&amp; nums[c2]>nums[c1]) ? c2 : c1; if (nums[c] > nums[p]) swap(nums[c], nums[p]); else break; p = c; } } vector&lt;int> heapSort(vector&lt;int>&amp; nums) { int n = nums.size(); for (int i = n/2-1; i >= 0; --i) { adjust(nums, i, n); } for (int i = n-1; i > 0; --i) { swap(nums[0], nums[i]); adjust(nums, 0, i); } return nums; } };","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://doublejun12.github.io/categories/编程算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://doublejun12.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://doublejun12.github.io/tags/算法/"}]}],"categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://doublejun12.github.io/categories/编程算法/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://doublejun12.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://doublejun12.github.io/tags/算法/"}]}