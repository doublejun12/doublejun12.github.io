{"meta":{"title":"SJ Zhang's Blog","subtitle":"MyBlog","description":"Fudan University","author":"Shuangjun Zhang","url":"https://doublejun12.github.io","root":"/"},"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"404.html","permalink":"https://doublejun12.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","updated":"2020-12-11T09:51:56.344Z","comments":true,"path":"about/index.html","permalink":"https://doublejun12.github.io/about/index.html","excerpt":"","text":"教育经历 在上海某野鸡高校读ph.d，虽然是计算机专业的人，但完全没有热情写代码。 研究兴趣在于理论计算机科学，特别是交互式证明系统(Interactive Proof Systems)和概率证明系统(Probabilistically Checkable Proof Systems)。 同时也对密码学有点兴趣。 数学完全不行，会的最高深的数学是本科水平的线性代数。 喜欢二刺螈和偶像，是萌萌人，有时是乐子人。 获得荣誉 一点也没有 一些我比较喜欢的课程 Probabilistically Checkable and Interactive Proof Systems (Alessandro Chiesa) Theory of Computation (Yijia Chen) Zero Knowledge (The 9th BIU Winter School on Cryptography) The PCP Theorem and Hardness of Approximation (Venkatesan Guruswami &amp; Ryan O’Donnell) Graph Partitioning, Expanders and Spectral Methods (Luca Trevisan) Randomized Algorithms) (Yitong Yin) Pseudorandomness (Salil Vadhan) Proofs, beliefs, and algorithms through the lens of sum-of-squares (Boaz Barak &amp; David Steurer) Complexity Theory (Jonathan Katz) TCS Toolkit (Ryan O’Donnell) Undergraduate Complexity Theory (Ryan O’Donnell) Graduate Computational Complexity Theory (Ryan O’Donnell) Quantum Computation and Quantum Information (Ryan O’Donnell) Essential Coding Theory (Madhu Sudan) 1/3都是Ryan O’D的课程，这大佬讲课真的清晰易懂。"},{"title":"archives","date":"2019-07-19T08:39:20.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"archives/index.html","permalink":"https://doublejun12.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-19T08:39:20.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"categories/index.html","permalink":"https://doublejun12.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2019-07-26T09:17:02.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"contact/index.html","permalink":"https://doublejun12.github.io/contact/index.html","excerpt":"","text":"欢迎留言大家有任何问题，都可以在评论区给我留言，或者加 QQ 技术交流群【群号：864832264】。 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：godweiyang 地址：https://godweiyang.com 简介：公众号【算法码上来】，分享深度学习与NLP算法 头像：https://godweiyang.com/medias/avatars/avatar.jpg"},{"title":"friends","date":"2019-07-19T08:42:10.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"friends/index.html","permalink":"https://doublejun12.github.io/friends/index.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址 例如我的博客友链，大家可以加到自己博客里哦： 名称：godweiyang 地址：https://godweiyang.com 简介：公众号【算法码上来】，分享深度学习与NLP算法 头像：https://godweiyang.com/medias/avatars/avatar.jpg"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2020-04-05T02:43:43.000Z","comments":true,"path":"tags/index.html","permalink":"https://doublejun12.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Max-E3SAT问题的不可近似性：从Cook-Levin到Håstad's E3-SAT Hardness","slug":"max-3sat","date":"2020-12-11T06:02:37.000Z","updated":"2020-12-14T17:45:02.138Z","comments":true,"path":"2020/12/11/max-3sat/","link":"","permalink":"https://doublejun12.github.io/2020/12/11/max-3sat/","excerpt":"","text":"[toc] 1. 前言​ 这学期花费了一段时间看了一遍Venkatesan Guruswami和Ryan O’Donnell两位大神关于PCP定理和不可近似性的lecture notes。PCP定理本身不必多说，后面关于不可近似性的内容也属实精彩。一直想写点东西把这方面的知识从头到尾总结一下，于是就诞生了这篇文章。本文预计从1971年Stephen Cook证明3SAT是$\\mathcal{NP}$完全问题开始说起，一直到2001年Håstad证明7/8是Max-3SAT问题的最优近似比结束，把这30年的研究历史简要概括一下，不涉及到一些证明的细节，我感兴趣的部分可能会展开详细说一下。由于本人水平实在不行，有任何写得不对的地方或者有问题的地方欢迎大家指出。 ​ 关于SAT问题，相信每个对计算理论有点了解的同学都不陌生，SAT问题说的是输入一个布尔表达式，问是否存在一种赋值方案，使得该布尔表达式被满足（结果为1）. 所谓的3SAT问题，指的就是该布尔表达式是一个合取范式(CNF)，该CNF中每个子句(clause)的变量个数不超过3个。如果每个子句变量的个数都恰好为3个的话，那么该问题称为E3SAT问题，一个E3SAT问题的实例(instance)如下： F=(x_1 \\lor \\overline{x_2} \\lor x_5) \\land (\\overline{x_1} \\lor \\overline{x_3} \\lor x_4) \\land (\\overline{x_2} \\lor x_3 \\lor x_5)在上述实例中，对变量赋值$x=(1,0,0,1,1)$就能使得上述表达式的值为1，也就是说该表达式是能被满足的。那么我们能否设计一个高效（多项式时间）的算法来判定E3SAT问题呢？ ​ 上述所说的几种SAT问题，指的都是判定问题（Decision Problem），也就是说这些问题的输出为$1$或者$0$，如果输入的表达式能满足的话就输出$1$，反之输出$0$。在理论计算机领域中，通常我们把一个判定问题结果为1的所有输入构成的集合称为是一个语言$\\mathcal{L}$。比如E3SAT问题对应的语言就是所有能被满足的3CNF表达式构成的集合。如果要求把最优赋值方案找出来，使得它能满足最多的子句，那这种问题称为搜索问题（Search Problem）记为Max-E3SAT。显然搜索问题不会比判定问题简单。 ​ 顺便一提，如果3SAT问题能在多项式时间内判定，并且输入的3CNF表达式能被满足的话，那该表达式的赋值方案也能在多项式时间内求解出来。假设存在多项式时间的算法D能判定3SAT问题，我们可以构造一个新的多项式时间的算法S找出能满足的赋值方案。比如输入的3SAT问题实例是$F$，有$n$个变量，先调用一次D，如果D返回能满足，我就先把$x_1$赋值为0，然后把得到的$F_1$再次提交给D，如果D返回能满足，我接下来就把$x_2$进行赋值……如果D返回不能满足的话，那我就明白把$x_1$赋值为1是一定能满足的，接着把赋值后的表达式再次提交给D。如此反复，也就是说我只要重复调用D $n$次就能把该赋值找出来。 2. 一切的起始：Cook-Levin定理2.1 Cook-Levin定理概述​ 很遗憾，Stephen Cook告诉我们，SAT问题是不存在多项式时间的算法的，除非$\\mathcal{P}=\\mathcal{NP}$。1971年Cook大神在读博期间发表了一篇名为 “The Complexity of Theorem Proving Procedures”的文章，该文章形式化地定义了复杂性领域中的两个基本概念“多项式时间规约（Polynomial-time Reduction）”和“$\\mathcal{NP}$完全（$\\mathcal{NP}$-Completeness）”。规约，指的就是把一个问题实例转化成另一个问题的实例，并保持实例的一些属性。比如从图的3着色问题规约到SAT问题，输入一个图，经过规约算法后输出一个布尔表达式，该布尔表达式可满足当且仅当输入的图是可以进行3着色的。所谓的$\\mathcal{P}$问题，指的就是能在多项式时间求解的问题。$\\mathcal{NP}$问题，指的是能在多项式时间内被验证的问题，$\\mathcal{NP}$问题的解也称为witness。$\\mathcal{NP}$完全问题指在$\\mathcal{NP}$中难度最大的问题，更严谨来说，$\\mathcal{NP}$完全问题是一种特殊的$\\mathcal{NP}$问题，其他所有的$\\mathcal{NP}$问题都能在多项式时间内规约到它。Cook也在该篇文章中证明了第一个$\\mathcal{NP}$完全问题：SAT。1982年，Cook因为该项工作获得图灵奖。 定理 2.1[Cook71]”Cook-Levin定理”： SAT是$\\mathcal{NP}$完全的。 我们可以简单地从SAT问题规约到E3SAT问题上来，所以E3SAT问题也是$\\mathcal{NP}$完全的。 ​ 这篇文章也留下了计算机科学领域最著名的问题：$\\mathcal{P}=\\mathcal{NP}$？也就是说多项式时间内能验证的问题是否一定能在多项式时间内求解？通过$\\mathcal{NP}$完全的定义我们可以意识到，如果$\\mathcal{NP}$完全问题能在多项式时间内求解的话，那么所有$\\mathcal{NP}$问题都将能在多项式时间内求解。所以如果E3SAT能在多项式时间内求解的话，那么所有$\\mathcal{NP}$问题（像什么图的3着色啊，哈密顿回路啊等等）都能在多项式时间内求解。一般人都认为$\\mathcal{P}$和$\\mathcal{NP}$是不太可能相等的（某些怪人除外），所以为E3SAT问题寻找多项式时间的算法大部分人认为是不可行的。既然判定E3SAT问题是一个难问题，那为E3SAT的实例找出一种最优的赋值方案当然是更难的问题。 2.2 我们能否找到近似解？​ 既然无法设计一个多项式时间的算法判定E3SAT问题，那我们能不能设计一个有效的算法找出一种赋值方案使得它尽可能满足多的子句呢？很简单，只要对每个变量进行随机赋值即可！那大家思考一下，这样的赋值方案从期望来说能让多少个子句被满足呢？没错！只要进行这样的一种平凡赋值就能让$7/8$的子句获得满足。这是因为在随机赋值的情况下每个子句被满足的概率为$7/8$，假设该表达式中有$m$个句子，那根据Linearity of Expectation，期望上有$7/8\\cdot m$的子句能被满足。通过Derandomization的方法可以将该算法转化成确定性算法，输出一种赋值方案满足$7/8$以上的子句。事实上，对于普通的3SAT问题，如果把某个实例中最多能被满足的子句数量记为$OPT$的话，我们也可以在多项式时间内找出一种赋值方案使得它能满足$7/8\\cdot OPT$的子句[Karloff97]。 ​ Cook-Levin定理告诉我们，找出Max-E3SAT问题的最优赋值方案（$100\\%$）是困难的，通过上面的分析我们明白找到一个$7/8$的近似解是简单的（即$7/8$近似算法）。那么我们能否能找到效果更好的算法呢？比如$8/9, 9/10,…$ ？多项式时间算法能达到的最优的近似比是多少？从Cook-Levin定理提出的30年之后，该问题才得到了回答。 3. “懒人”的证明系统：PCP定理3.1 交互式证明系统​ 我们先抛开上述Max-E3SAT问题，把目光移向密码学界。1985年，Cook-Levin定理被证明后过了14年，密码学领域出现了一篇很有趣的论文”The Knowledge Complexity of Interactive Proof Systems”。作者为Goldwasser, Micali, 以及Rackoff[GMR85]。这篇论文的工作对密码学领域与计算复杂性领域产生了非常重大的影响，Goldwasser, Micali也由于该项工作（还有一些其他密码学上的贡献）获得了2012年图灵奖。有趣的是，这篇文章投稿过FOCS’83，STOC‘84，FOCS’84，但都被拒绝了，一直到STOC‘85才被接收。这篇文章定义了两个新的概念，称为交互式证明系统（Interactive Proof Systems）与零知识证明（Zero-Knowledge Proof Systems）。关于零知识证明方面，相信了解区块链的同学一定不陌生。这是一种非常神奇的证明系统，比如我想向你证明某个命题的准确性，我能在不泄露额外秘密的情况下让你相信一个命题的真假性。本文不会讲零知识证明方面的内容，有兴趣的同学可以看看Bar-Ilan University的零知识证明课程。 ​ 那么什么是交互式证明系统呢？证明系统指的其实就是一个计算能力无限的证明者（Prover）与概率多项式时间的验证者（Verifier）双方的一个游戏，验证者借助证明者帮她判断某个命题的真假。我们首先回顾一下关于$\\mathcal{NP}$的定义，$\\mathcal{NP}$问题说的是在多项式时间内能判定的问题，那其实对于任何一个$\\mathcal{NP}$问题都可以建立一个平凡的一轮证明系统——对于3SAT问题，证明者只要把最优的赋值方案发送给验证者即可，验证者可以自己验证该表达式能不能被满足。交互式证明系统指的是证明者验证者双方可以进行多轮的交互，并且验证者有coin-tossing的能力（也就是随机算法）。把所有能建立交互式证明的语言构成的集合称为$\\mathcal{IP}$，$\\mathcal{NP}$就是$\\mathcal{IP}$的一个平凡子集。那么$\\mathcal{IP}$包含$\\mathcal{NP}$外的其他语言吗？事实上1990年Shamir证明了$\\mathcal{IP}=\\mathcal{PSPACE}$，也就是说任何多项式空间能判定的问题都可以建立一个交互式证明系统。 ​ 1988年，Michael Ben-Or, Goldwasser, Joe Kilian, 和Wigderson为了移除零知识证明中的某些密码学假设，提出了多证明者的交互式证明系统[BGKW88]。在这种证明系统中，证明者可以有多个并且相互之间不能进行通信。作者证明了多个证明者（多项式多个证明者）和两个证明者是等价的。把所有能建立此类证明系统的语言记为$\\mathcal{MIP}$， Babai, Fortnow, and Lund证明了$\\mathcal{MIP}=\\mathcal{NEXP}$，也就是所有能在指数时间内验证的问题都可以设计一个多证明者的交互式证明系统。从直觉上考虑，两个证明者之间不能进行通信，所以证明者进行欺骗的概率就大大降低了，也就是说双证明者的证明复杂性要小于单证明者（验证者提问的次数减小了），这个直觉直接促使了后续PCP理论的诞生与发展（这篇文章的工作也促使了Derandomization领域的诞生与发展）。Fortnow，Rompel，Sisper证明了$\\mathcal{MIP}$与一种叫Oracle Proof System的系统是等价的[FRS88]。 引理3.1[FRS88]： 令$\\mathcal{L}$是一个语言，$M$是概率多项式时间的oracle图灵机使得 $x \\in L \\Rightarrow $ 存在一个Oracle $\\mathcal{O}$使得$M^{\\mathcal{O}}$以大于$c$的概率接受$x$。 $x \\notin L \\Rightarrow $ 对于任意的Oracle $\\mathcal{O}$，$M^{\\mathcal{O}}$以小于$s$的概率接受$x$。 则语言$\\mathcal{L}$存在一个双证明者的交互式证明协议。（$\\mathcal{L} \\in \\mathcal{MIP}$） Oracle 可以理解为$\\mathcal{O}$是$M$的黑盒子程序，$M$可以不断地对$\\mathcal{O}$进行提问，获得相应的回答。事实上，这个Oracle Proof System其实就是下文要说明的一个重要概念：概率可验证证明PCPs（Probabilistic Checkable Proofs） 3.2 概率可验证证明​ 上文所提到的Oracle Proof System，其实可以理解为这么一回事，把这个Oracle $\\mathcal{O}$看成是证明者提供的一段证明。证明者把关于某个命题的证明$\\pi$写下来之后，验证者可以随机选择该证明中的几个位置来判断该命题是否是正确的，这其实就是概率可验证证明PCPs。 定义3.2：令$\\mathcal{L}$是一个语言，$M$是概率多项式时间的图灵机使得 $x \\in L \\Rightarrow $ 存在证明 $\\pi$ 明使得$M^{\\pi}$以大于$c$的概率接受$x$。（$c$也成为该证明系统的完备性Completeness） $x \\notin L \\Rightarrow $ 对于任意的证明 $\\pi$，$M^{\\pi}$以小于$s$的概率接受$x$。（$s$也成为该证明系统的稳健性Soundness） 则称语言$\\mathcal{L}$存在概率可验证证明，若$M$使用了$O(r(n))$个随机比特，查询了证明中的$O(q(n))$个位置，并且证明中的所有字符都是字母表$\\Sigma$中的元素，则称$\\mathcal{L} \\in \\mathcal{PCP}_{c,s}[r(n), q(n)]_{\\Sigma}$. ​ 一个显然的结论是 $\\mathcal{NP} \\subseteq \\mathcal{PCP}_{1,0}[0,poly(n)]_{\\{0,1\\}}$，这是由于$\\mathcal{NP}$的定义，PCP证明者直接把witness当成是一段证明，验证者把整段证明读取下来后在确定性多项式时间内进行验证就行了。如果允许验证者进行coin-tossing，那么我们能否降低查询复杂性？答案是YES！其实并不需要把整段证明都读取下来，只要证明者对witness以一种特殊的方式进行编码，我们可以只查询常数个位置就能判断某个命题的真假。这就是计算复杂性理论中大名鼎鼎的PCP定理。 定理3.3[ALMSS92]”PCP Theorem”：$\\mathcal{NP} \\subseteq \\mathcal{PCP}_{1,1/2}[\\log n,1]_{\\{0,1\\}}$. ​ 比如某人告诉你他证明了黎曼猜想，并且把证明发送给了你，但你是个非常懒惰的人，根本没有时间阅读这整段证明。PCP定理告诉我们，若把这段证明进行特殊编码，你只需要使用 $\\log n$ 个随机比特，然后查询证明中的常数个位置的比特，你就可以以较大的概率判断这段证明的真假性！“懒人”也可以当一个好“评委”！ ​ Arora，Lund，Motwani，Sudan，Szegedy等人在1992年首先证明了PCP定理，但是证明过程非常昂长，完整版论文长达150多页。后人有对这一版的证明进行过整理，证明思路还是非常清晰的。首先使用Hadmard码与Linearity Testing的技术构造指数证明长度的PCP（$\\mathcal{NP} \\subseteq \\mathcal{PCP}_{1,1/2}[poly(n),1]_{\\{0,1\\}}$，该结论的证明较为简单，任何Graduate Complexity课程一般都会涉及，我个人是在看这个证明的过程中开始对PCP感兴趣的，这也是我第一次接触到编码和布尔函数的傅里叶分析领域），其次使用Low-Dgree Extension的方法与Low-Degree Testing再加上Sumcheck Protocol构造多项式规模的PCP（$\\mathcal{NP} \\subseteq \\mathcal{PCP}_{1,1/2}[\\log(n),polylog(n)]_{\\{0,1\\}}$），然后使用上述两个PCP构造Robust PCP与PCP of Proximity，最后用Proof Composition的方法对上述的PCP进行整合得到最终的PCP定理（也许后面我会写点这方面的博客）。完整的证明过程推荐Alessandro Chiesa的课程 Probabilistically Checkable and Interactive Proof Systems，这位大佬用了12节课完成了PCP定理的证明。2005年，Irit Dinur用了图论和组合的方式重新证明了PCP定理（下文将详细说明），把证明的过程缩减到了30页左右。关于Irit Dinur的证明过程，推荐Venkatesan Guruswami和Ryan O’Donnell的lecture notes The PCP Theorem and Hardness of Approximation ，这也是本文的主要参考文献。这两版的证明分别于2001年与2019年获得哥德尔奖。 3.3 Gap问题与不可近似性​ 上面介绍了一堆和证明系统相关的东西，和本文的主题“不可近似性”有什么关系呢？在回答这个问题之前，我们先来回忆一下E3SAT问题的定义，E3SAT问题说的是输入一个有$m$个子句的表达式，若所有子句都能被满足则输出YES，若至少有一个子句不能被满足则输出NO。我们可以把这两种情况进行一般化定义$GAP-E3SAT_{c,s}$问题。 定义3.4”$GAP-E3SAT_{c,s}(0&lt;s \\leq c \\leq 1)$”：给定一个有$m$个子句的E3SAT表达式， 若$OPT \\geq cm$，则输出YES。 若$OPT &lt; sm$，则输出NO。 若$sm \\leq OPT &lt; cm$，则可任意输出。 当 $c=1, s=1-1/m$时，这就是正常的E3SAT问题，是NP-hard的。注意到如果上述GAP问题是NP-hard的话，那对于MAX-3SAT来说就不存在$(s/c)$-近似算法了。假设MAX-3SAT存在$(s/c)$-近似算法$A$，如果输入的3SAT表达式 $\\psi$ 满足 $OPT \\geq cm$，则 $A(\\psi) \\geq (s/c)\\cdot OPT \\geq (s/c)\\cdot cm = sm$。如果输入的3SAT表达式 $\\psi$ 满足 $OPT &lt; sm$，则 $A(\\psi) &lt; OPT \\leq sm$。所以该多项式时间的算法能对GAP问题中的两种情况进行区分，与该问题是NP-hard是相矛盾的。 ​ 令人震惊的是，上述GAP问题的NP-hard性与PCP定理是等价的！！PCP定理也可以表述为： 定理3.5”PCP Theorem”： 存在一个常数$s$，使得$GAP-E3SAT_{1,s}$ 是NP-hard的。 ​ 从表面上看，定理3.3与定理3.5是两个完全不同的定理，定理3.3说的是一个证明系统，定理3.5是一个问题的难解性。接下来，我们将花点篇幅证明定理3.3与3.5的等价性。 定理3.3与定理3.5的等价性证明： 首先从定理3.5推出定理3.3：假设$GAP-3SAT_{1,s}$是$\\mathcal{NP}$难的，构造该的PCP系统。给定一个3SAT表达式$\\psi$包含$n$个子句。证明者将提供$\\psi$的赋值。$V$使用$\\log $个随机比特n选择一个随机的子句$\\phi$，查询该子句中变量的赋值，验证该子句是否能被满足。注意到此时需要查询的比特数量为3。该PCP系统满足下列属性： 完备性：若$OPT=n$，则证明者只要提供能满足的赋值即可，验证者接受的概率为1. 稳健性：若$OPT&lt;sn$，则不管证明者怎么进行赋值，能满足的表达式最多有$sn$个，验证者选择到的概率不超过$s$，也就是说验证者验证接受的概率小于$s$。通过独立并行重复检查$O(1)$个字句后能把概率降低到$1/2$以下。 4. 与“双子上帝”进行博弈：Parallel Repetition定理4.1 Label Cover问题4.2 双证明者的一轮博弈（2P1R Game）4.3 为什么并行重复博弈是非平凡的？4.4 Gap无限放大： Parallel Repetition定理5. 你是一名“独裁者”吗？Håstad’s 3-query PCP5.1 震惊！线性方程组也是难问题！（Max-E3LIN2问题）5.2 “独裁者”测试5.3 Håstad’s 3-query PCP6. 最后的碎片：从Max-E3LIN-2归约到Max-E3SAT最后，我们回到Max-E3SAT问题上来，证明$7/8$是Max-E3SAT问题最优的近似比。","categories":[{"name":"计算复杂性","slug":"计算复杂性","permalink":"https://doublejun12.github.io/categories/计算复杂性/"}],"tags":[{"name":"NP完全定理","slug":"NP完全定理","permalink":"https://doublejun12.github.io/tags/NP完全定理/"},{"name":"不可近似性","slug":"不可近似性","permalink":"https://doublejun12.github.io/tags/不可近似性/"},{"name":"PCP定理","slug":"PCP定理","permalink":"https://doublejun12.github.io/tags/PCP定理/"},{"name":"Parallel Repetition定理","slug":"Parallel-Repetition定理","permalink":"https://doublejun12.github.io/tags/Parallel-Repetition定理/"}]},{"title":"消息认证编码，认证加密","slug":"mac-1","date":"2020-12-08T15:23:20.000Z","updated":"2020-12-10T17:06:46.341Z","comments":true,"path":"2020/12/08/mac-1/","link":"","permalink":"https://doublejun12.github.io/2020/12/08/mac-1/","excerpt":"","text":"1. 消息认证编码-定义消息认证编码的目的是为了保护消息在传输过程中不被攻击者修改，接收者能验证消息的完整性。 1.1. 消息认证编码的定义一个消息认证编码MAC（Message Authentication Code）由三个概率多项式（Gen, Mac, Vrfy）时间的算法构成： Gen: 输入安全参数$1^n$, 输出密钥$k$, 要求$|k| \\geq n$. Mac: 输入密钥$k$, 消息$m \\in \\{0, 1\\}^*$, 输出标签tag, $t \\leftarrow Mac_k(m)$. Vrfy: 输入密钥$k$, 标签$t$, 输出比特$b \\leftarrow Vrfy_k(m, t)$. 若$b=1$, 则表示“有效”，反之表明“无效”。 正确性要求$Vrfy_k(m, Mac_k(m))=1$. 1.2 MAC的安全性定义给定一个MAC方案$\\Pi $，考虑如下游戏： 挑战者运行$Gen(1^n)$，获得密钥$k$. 攻击者输入$1^n$, 适应性地进行消息查询，将消息记为$m_1, m_2, \\cdots , m_{q}$. 挑战者返回对应的MAC $t_1, t_2, \\cdots, t_{q}$. 攻击者宣布其挑战消息$m$, 并生成对应的MAC $t$. 攻击者成功当且仅当（1）$Vrfy_k(m, t) = 1$ 并且（2）$m \\notin \\{m_1, m_2, \\cdots , m_{q}\\}$. 将上述游戏中攻击者$A$成功的概率记为$Pr[S]$. 一个MAC方案$\\Pi$在适应性选择明文攻击下是存在不可伪造的EU-CMA（Existentially Unforgeable under an adaptive Chosen-Message Attack）如果对于所有的概率多项式时间算法$A$, 存在一个可忽略的函数$negl(n)$, 使得： $Pr[S] \\leq negl(n)$. 2. 构造安全的MAC2.1 固定消息长度的MAC方案Construction 2.1： 假设$F$为伪随机函数，定义消息长度为$n$的MAC方案： $Gen(1^n)$: 选择随机均匀密钥$k \\leftarrow \\{0,1\\}^{n}$, 并输出。 $Mac(m, k)$: 输出标签$t:=F_k(m)$.（若$|m| \\neq |k|$则不输出任何值。） $Vrfy(k,m,t)$: 若$t=F_k(m)$, 则输出1，反之输出0. Theorem 2.2：若$F$为伪随机函数，则上述构造为安全的定长MAC方案。 Proof：假设$A$为一个概率多项式时间的攻击者，定义两个游戏Game 0, Game 1. Game 0: 挑战者选择密钥$k \\leftarrow \\{0, 1\\}^{n}$. 攻击者适应性地查询$Q = \\{m_1, \\cdots, m_q\\}$ 对应的tag, 挑战者返回$\\{t_1, \\cdots, t_q\\}$, 其中$t_i = F_k(m_i)$. 攻击者输出消息-tag对$(m, t)$, 若$t=F_k(m), m \\notin Q$, 则攻击者成功。 将攻击者在Game 0中成功的概率记为$S_0$. 将伪随机函数改为真随机函数$f$, 得到Game 1. Game 1: 挑战者选择密钥$k \\leftarrow \\{0, 1\\}^{n}$. 攻击者适应性地查询$Q = \\{m_1, \\cdots, m_q\\}$ 对应的tag, 挑战者返回$\\{t_1, \\cdots, t_q\\}$, 其中$t_i = f(m_i)$. 攻击者输出消息-tag对$(m, t)$, 若$t=f(m), m \\notin Q$, 则攻击者成功。 将攻击者在Game 1中成功的概率记为$S_1$. Claim 1: $Pr[S_1] = 2^{-n}$ . Proof of Claim 1: 显然当$m$从未被查询过时，$f(m)$的值为$\\{0,1\\}^{n}$上的随机元素，刚好取到$t$的概率为$2^{-n}$. Claim 2: $|Pr[S_0] - Pr[S_1]| \\leq negl(n)$. Proof of Claim 2: 我们使用归约论证来证明该结论，假设攻击者$A$能成功伪造MAC, 我们构造新的算法D来区分真随机函数与伪随机函数。 算法D: 算法D的输入为$1^n$, 并且D能查询预言$O: \\{0,1\\}^n \\rightarrow \\{0,1\\}^n$, 该算法的作用为区分$O$究竟是 真随机函数还是伪随机函数。 运行$A(1^n)$, 当$A$用消息$m$来查询MAC预言时，如下回答： (a)用$m$查询预言$O$, 返回值记为$t$, 将$t$值给$A$. 当$A$结束运行并输出$(m,t)$时： (a)用$m$查询预言$O$, 返回$t’$. (b)如果$t=t’$并且$A$之前从来没有查询过$m$, 则输出1, 反正输出0. 显然，D是多项式时间算法。 算法D的分析： Case 1: 当$D$的预言$O$是伪随机函数时，攻击者$A$在Game 0中，此时$D$输出1当且仅当$A$在Game 0中成功，所以， $Pr[D^{F_k(\\cdot)}(1^n)=1]=Pr[S_0]$. Case 2: 当$D$的预言$O$是真随机函数时，攻击者$A$在Game 1中，此时$D$输出1当且仅当$A$在Game 1中成功，所以， $Pr[D^{f(\\cdot)}(1^n)=1]=Pr[S_1]$. 因为$F_k$为伪随机函数，所以我们有： $|Pr[S_0]-Pr[S_1]| = |Pr[D^{F_k(\\cdot)}(1^n)=1]-Pr[D^{f(\\cdot)}(1^n)=1]|\\leq negl(n)$. Claim 2证明完毕。 结合Claim 1​和Claim 2我们有$|Pr[S_0]-2^{-n}| \\leq negl(n)$, 即$Pr[S_0] \\leq 2^{-n}+negl(n)$是可忽略的。 所以攻击者A成功伪造的概率可忽略，构造2.1是安全的MAC方案。 2.2. 任意消息长度的MAC方案假设$\\Pi’=(Mac’, Vrfy’)$是定长的MAC方案，将$m$进行分块获得$m_1, \\cdots, m_d$. 思路1: 直接分块计算$t_i:=Mac_k^{‘}(m_i)$, 输出$$. 但这无法抵抗块重排序攻击，假设$(t_1, t_2)$为$(m_1, m_2)$对应的有效MAC. 则攻击者知道$(m_2, m_1)$对应的有效MAC是$(t_2,t_1)$. 思路2: 在每个块上加上块指数$i$, $t_i := Mac’_k(i||m_i)$, 这就能抵御块重排序攻击。但这无法抵御截断攻击，攻击者直接将最后一个区块去掉。比如$(t_1, t_2)$为$(m_1, m_2)$对应的有效MAC. 则攻击者知道$m_1$对应的有效MAC是$t_1$. 思路3: 每个块上加上消息的长度$l$, $t_i:=Mac’_k(l||i||m_i)$, 这能抵御截断攻击，因为截断后长度改变。但这无法抵挡混淆攻击。比如攻击者已知$(m_1,m_2)$的MAC值为$(t_1,t_2)$, $(m’_1, m’_2)$的MAC值为$(t’_1,t’_2)$. 则攻击者能知道$(m_1, m’_2)$的MAC值为$(t_1, t’_2)$. Construction 2.3: 假设$\\Pi’=(Mac’, Vrfy’)$是固定长度$n$的MAC方案，则如下定义一个新的MAC： $Gen(1^n)$: 选择随机均匀密钥$k \\leftarrow \\{0,1\\}^{n}$, 并输出。 $Mac(m, k)$: 输入的消息$m \\in \\{0,1\\}^*$长度为$l &lt; 2^{n/4}$. 将 $m$ 分成 $d$ 个块$m_1, m_2, \\cdots, m_d$, 每个块长度为$n/4$（最后的块用0补足）。选择随机标识符$r \\in \\{0,1\\}^{n/4}$. 对于$i=1,2,\\cdots,d$, 计算$t_i \\leftarrow Mac’_k(r||l||i||m_i)$, $i, l$都用$n/4$长度的字符串来表示。输出标签$t=(r,t_1,t_2,\\cdots, t_d)$. $Vrfy(k,m,t)$: 输入标签$t = (r,t’_1, \\cdots, t’_{d’})$，输入的消息$m \\in \\{0,1\\}^*$长度为$l &lt; 2^{n/4}$. 将$m$分成$d$个块$m_1, m_2, \\cdots, m_d$, 每个块长度为$n/4$（最后的块用0补足）。首先验证$d=d’$是否成立，其次对于$1\\leq i \\leq d$ 验证$t’_i=Mac’_k(r||l||i||m_i)$. 若验证均通过，输出1，反之输出0. Theorem 2.4: 假设$\\Pi’$为长度为$n$安全的定长MAC方案，那么上述构造是任意长度的安全MAC方案。 Proof: 假设$A$为概率多项式时间的攻击者，我们把$A$成功伪造上述MAC方案记为事件$S$, 我们要证明$Pr[S]$是可忽略的。 符号说明： 令$(m,t=)$为攻击者最后的输出，其中$m=m_1, \\cdots$. Repeat: 攻击者查询MAC预言得到的一系列tag值中，有两个随机标识符一样。 NewBlock: 至少有一个块$r||l||i||m_i$在A的预言查询时从来未被$Mac’_k$认证过。 $Pr[S]=Pr[S \\land Repeat]+Pr[S \\land \\overline{Repeat} \\land NewBlock]+Pr[S \\land \\overline{Repeat} \\land \\overline{NewBlock}]$ $\\leq Pr[Repeat]+Pr[S \\land NewBlock]+Pr[S \\land \\overline{Repeat} \\land \\overline{NewBlock}]$ 我们证明右边三个概率都是可忽略的。 Claim 1: $Pr[Repeat]$是可忽略的。 Proof of Claim 1: 令事件$H_{i,j}$为第$i$次查询和第$j$次查询选择的随机标识符一致。则由于标识符的长度为$2^{n/4}$, 我们有$Pr[H_{i,j}]=\\frac{1}{2^{n/4}}$. 假设攻击者查询的次数为$q(n)$, $q$为某个多项式，那么 $Pr[Repeat] = Pr[\\cup_{1 \\leq i &lt; j \\leq q(n)} H_{i,j}] = \\sum_{i,j} Pr[H_{i,j}] = C_{q(n)}^2\\frac{1}{2^{n/4}} \\leq \\frac{q(n)^2}{2^{n/4}}$ 该值为可忽略的值。 Claim 2: $Pr[S \\land \\overline{Repeat} \\land \\overline{NewBlock}]=0$ 我们证明如果攻击者伪造成功且MAC查询时随机标识符都不相同，则NewBlock必然发生。 Proof of Claim 2: 再次假设$q=q(n)$为攻击者进行MAC查询的次数。事件Repeat没有发生，则$r_1,r_2,…,r_q$各不相同。若$r \\notin \\{r_1,r_2,…,r_q\\}$, 则显然NewBlock发生。 若存在$j$, 使得$r=r_j$, 假设$r_j$为攻击者第$j$次查询的标识符，对应的消息为$m^{(j)}$, 长度为$l_j$. Case 1: $l \\neq l_j$, 则所有块的第二个分量都不一样，显然块$r||l||1||m_1$从未被查询过。NewBlock显然发生。 Case 2: $l = l_j$, 则由于攻击者伪造成功了，我们有$m \\neq m^{(j)}$. 假设$m$与$m^{(j)}$的第$i$个块不一致，即$m_i \\neq m_i^{(j)}$. 那么显然$r||l||i||m_i$是新的块。NewBlock也发生。 综上所述，$S \\land \\overline{Reapeat}$ 发生则NewBlock一定发生。 $Pr[S \\land \\overline{Repeat} \\land \\overline{NewBlock}] = 0$. Claim 3: $Pr[S \\land NewBlock]$是可忽略的。 我们用归约来证明Claim 3，假设有多项式时间攻击者$A$成功伪造MAC，我们构造新的多项式时间攻击者$A$来伪造方案$\\Pi’$的MAC，这与我们的假设相反。 Proof of Claim 3: 攻击者$A’$: 输入为$1^n$, 能用$Mac’_k(\\cdot)$进行MAC预言查询。 ​ 把攻击者$A$当成子程序。 当攻击者$A$用 $m$（长度为 $l$）进行$Mac_k(\\cdot)$查询时: (a)将$m$分成长度为$n/4$的块$m_1, m_2,…m_d$（假设有$d$个块），最后不够的用0补足。 (b)随机选择标识符$r \\in \\{0,1\\}^{n/4}$, 对于$1 \\leq i \\leq d$, 用 $r||l||i||m_i$ 查询预言$Mac’_k(\\cdot)$得到$t_i$. (c)返回 $$. 当攻击者$A$输出伪造$(m, t = $时，检查$NewBlock$是否发生： (a)若发生，假设$r||l||i||m_i$是新的块从未被认证过，则输出$$. (b)若未发生，输出失败。 显然，攻击者$A$作为$A’$的子程序时和在原始的攻击游戏中完全一致。 假设$NewBlock$ 发生，则块 $r||l||i||m_i$ 从来未被认证过。 假设$S$发生，攻击者$A$伪造成功，则所有块的tag值均有效，$t_i = Mac’_k(r||l||i||m_i)$. 所以如果$S \\land NewBlock$发生，则攻击者$A’$成功伪造了$r||l||i||m$ 的MAC值。 假设攻击者$A’$成功的事件为$S’$, 我们有$Pr[S \\land NewBlock] \\leq Pr[S’]$. 根据我们的假设 $\\Pi’$ 为安全的MAC方案，所以$Pr[S’]$可忽略，从而得到 $Pr[S \\land NewBlock]$ 可忽略。 综合Claim 1,2,3, $Pr[S]$可忽略，该方案是安全的MAC方案。 3. CBC-MAC上一节构造的MAC方案效率低，比如计算消息长度为$dn$的MAC值，需要进行$4d$次分组计算，最后的tag长度为$4dn$. 本节给出更有效的构造。 3.1. 基本构造Construction 3.1: 假设$F$是伪随机函数，固定长度函数$l&gt;0$. 基本的CBC-MAC方案如下构造： $Gen(1^n)$: 随机选择$k \\leftarrow \\{0, 1\\}^n$, 输出作为密钥。 $Mac(k, m)$: 输入消息的长度为$l(n) \\cdot n$, 进行如下计算： (a). 将$m$分成$m_1, m_2, … , m_l$, 每个$m_i$的长度为$n$. (b). 令$t_0=0^n$, 对于$i$从1到$l$, 计算： ​ $t_i = F_k(t_{i-1} \\oplus m_i)$. (c). 输出$t_l$作为tag. $Vrfy(t, m, k)$: 若$m$的长度不是$l(n) \\cdot n$ 输出0，否则输出1当且仅当$t = Mac(k, m)$. Theorem 3.2: 假设F是伪随机函数，$l$为多项式，则上述方案对于长度为$l(n) \\cdot n$的消息来说是安全的MAC方案。 下一节证明一个更一般的结论。 *3.2. 安全性证明本节稍有难度，可以选择跳过不影响后面学习。 定义CBC函数，输入为$(\\{0,1\\}^n)^*$中的元素（也就是长度为n的倍数）以及长度为n的密钥映射到长度为n的字符串。 $CBC_k(x_1,…,x_l)=F_k(F_k( \\cdots F_k(F_k(x_1) \\oplus x_2) \\oplus \\cdots ) \\oplus x_l)$. $|x_1|=|x_2|=\\cdots=|x_l|=|k|=n$. 一个字符串集合$P \\subset (\\{0,1\\}^n)^*$是无前缀的如果它不包含空串以及任何字符串 $X \\in P$ 都不是其它字符串 $X’ \\in P$ 的前缀。 Theorem 3.3: 对于任意的概率多项式时间算法$D$, $D$ 能进行预言查询，但所有查询的字符串构成的集合是无前缀的。存在可忽略的函数$negl$, 使得， $|Pr[D^{CBC_k(\\cdot)}(1^n)=1]-Pr[D^{f(\\cdot)}(1^n)=1]| \\leq negl(n)$. 我们可以用一个编码函数$encode$, 将任意长度的字符串$m$映射到 $encode(m) \\in (\\{0,1\\}^n)^*$, 然后输出$CBC_k(encode(m))$. 该编码方案需要是无前缀的。 我们证明当CBC的“密钥”是一个随机函数$g$时的安全性，也就是说定义 $CBC_g(x_1,…,x_l)=g(g( \\cdots g(g(x_1) \\oplus x_2) \\oplus \\cdots ) \\oplus x_l)$. 我们证明$CBC_g(\\cdot)$与$(\\{0,1\\}^n)^*$到$\\{0,1\\}^n$上的随机函数就是不可区分。 Theorem 3.4: 固定$n \\geq 1$, 取随机函数$g:\\{0,1\\}^n \\rightarrow \\{0, 1\\}^n, f:$$(\\{0,1\\}^n)^* \\rightarrow \\{0,1\\}^n$, 对于任意（无时间限制）算法$D$, $D$ 能进行$q$次预言查询，但这$q$次查询的字符串构成的集合是无前缀的，并且所有的查询中最长的消息包含$l$个区块。则 $|Pr[D^{CBC_g(\\cdot)}(1^n)=1]-Pr[D^{f(\\cdot)}(1^n)=1]| \\leq \\frac{q^2 l^2}{2^n}$. Proof of Theorem 3.4: 假设$P=\\{X_1,…,X_q\\}$为无前缀的q次查询，每个$X_i \\in (\\{0, 1\\}^n)^*$, 且$P$中最长的消息包含$l$个区块。对于任意的$t_1,…,t_q \\in \\{0,1\\}^n$, 有$Pr[\\forall i:f(X_i)=t_i] = 2^{-nq}$. 我们称CBC是$(q,l,\\delta)-smooth$的如果对于每个无前缀集合$P=\\{X_1,…,X_q\\}$, 以及每个$t_1,…,t_q \\in \\{0,1\\}^n$ ,有 $Pr[\\forall i: CBC_g(X_i)=t_i] \\geq (1-\\delta) \\cdot 2^{-nq}$. 也就是说 $(q,l,\\delta)-smooth$ 的CBC是 $\\delta-close$ 真随机函数 $f$ 的。 Claim 3.5: $CBC_g$是$(q,l,\\delta)-smooth$的，其中 $\\delta = q^2l^2 \\cdot 2^{-n}$. 下面假设Claim 3.5成立。 定义函数$\\alpha(X_1,…,X_q;t_1,…, tq) = 1$当且仅当$D$查询$X_1,…,X_q$时返回$t_1,…,t_q$, 且$D$最后输出1. 令$\\overrightarrow{X} = \\{X_1,…,X_q\\}$, $\\overrightarrow{t} = \\{t_1,…,t_q\\}$, 我们有 $\\operatorname{Pr}\\left[D^{\\mathrm{CBC}_{g}(\\cdot)}\\left(1^{n}\\right)=1\\right]$ $=\\sum_{\\vec{X} \\text { prefix-free; } \\vec{t}} \\alpha(\\vec{X}, \\vec{t}) \\cdot \\operatorname{Pr}\\left[\\forall i : \\mathrm{CBC}_{g}\\left(X_{i}\\right)=t_{i}\\right]$ $\\geq \\sum_{\\vec{X} \\text { prefix-free; } \\vec{t}} \\alpha(\\vec{X}, \\vec{t}) \\cdot(1-\\delta) \\cdot \\operatorname{Pr}\\left[\\forall i : f\\left(X_{i}\\right)=t_{i}\\right]$ $=(1-\\delta) \\cdot \\operatorname{Pr}\\left[D^{f(\\cdot)}\\left(1^{n}\\right)=1\\right]$, 这证明了 $\\operatorname{Pr}\\left[D^{f(\\cdot)}\\left(1^{n}\\right)=1\\right]-\\operatorname{Pr}\\left[D^{\\mathrm{CBC}_{g}(\\cdot)}\\left(1^{n}\\right)=1\\right] \\leq \\delta \\cdot \\operatorname{Pr}\\left[D^{f(\\cdot)}\\left(1^{n}\\right)=1\\right] \\leq \\delta$. 完成Theorem 3.4的证明。 下面进行Claim 3.5的证明。 Proof of Claim 3.5: 令$X \\in\\left(\\{0,1\\}^{n}\\right)^{*}$, 且$X=x_1,…$并且$, |x_i|=n$. 令$C_g(x)$是 计算$CBC_g(X)$过程中$g$的输入构成的集合。例如假设$X \\in\\left(\\{0,1\\}^{n}\\right)^{m}$, 那么 $\\mathcal{C}_{g}(X) \\stackrel{\\mathrm{def}}{=}\\left(x_{1}, \\mathrm{CBC}_{g}\\left(x_{1}\\right) \\oplus x_{2}, \\ldots, \\mathrm{CBC}_{g}\\left(x_{1}, \\ldots, x_{m-1}\\right) \\oplus x_{m}\\right)$. 令$X \\in\\left(\\{0,1\\}^{n}\\right)^{m}$, $X’ \\in\\left(\\{0,1\\}^{n}\\right)^{m’}$. $C_g(X)=(I_1,…,I_m), C_g(X’)=(I’_1,…,I’_{m’})$. 称$X$内部存在非平凡碰撞如果存在 $I_i=I_j$ 但是 $i \\neq j$. 称$X,X’$之间存在非平凡碰撞如果存在 $I_i = I’_j$ 但是$\\left(x_{1}, \\ldots, x_{i}\\right) \\neq\\left(x_{1}^{\\prime}, \\ldots, x_{j}^{\\prime}\\right)$. 称字符串集合$P=\\{X_1,…,X_q\\}$ 存在非平凡碰撞若存在 $X \\in P$ 有内部碰撞或者存在$X,X’ \\in P$之间存在碰撞。 定义事件 $Coll$ 为集合P存在非平凡碰撞。 我们分两部来完成证明： 第一步：如果 $Coll$ 未发生，则 $\\operatorname{Pr}\\left[\\forall i : \\operatorname{CBC}_{g}\\left(X_{i}\\right)=t_{i} | \\overline{\\mathrm{Coll}}\\right]=2^{-n q}$. 第二步：证明 $Coll$ 发生的概率小于$\\delta \\leq q^2l^2\\cdot 2^{-n}$. 对于$X$, 随机均匀选择 $g(I_1)$ 的值，确定$I_2=g(I_1) \\oplus x_2$, 随机均匀选择$g(I_2)$的值，如此重复，直到选择 $g(I_{m-1})$ 的随机值（无需选取$g(I_m)$的值，因为$g(I_m) \\notin C_g(X)$）。用上述方式计算出字符串$X_1,…,X_q$对应的$C_g(X_1),…,C_g(X_q)$，然后就可检查事件 $Coll$ 是否发生。 假设事件$Coll$未发生，那么$C_g(X_1),…,C_g(X_q)$中的最后一项必不相同。我们证明$g$在这些最后一项上的值未被确定，假设$C_g(X)$的最后一项$I_m$的$g$值已经被确定，那么肯定存在$I’_j$, $I_m = I’_j$并且 $I’_j$ 不是$C_g(X’)$的最后一项。但是由于事件$Coll$未发生，上述事件只有当$(x_1,…,x_m) = (x’_1,…,x’_j)$发生时才发生，但由于$X \\neq X’$, 我们得到$X$是$X’$的前缀，这与$P$无前缀相矛盾。 $CBC_g(X_i)$的值就是$g$在$C_g(X_i)$上最后一项的值。根据上述分析，$g$在最后一项上的值未被确定，所以从$\\{0,1\\}^n$上独立均匀选出，选择到某个固定值的概率为$2^{-n}$. 选择任意的$t_1,…,t_q \\in \\{0,1\\}^n$, 有 $\\operatorname{Pr}\\left[\\forall i : \\operatorname{CBC}_{g}\\left(X_{i}\\right)=t_{i} | \\overline{\\mathrm{Coll}}\\right]=2^{-n q}$. 第一步证明完毕，下面进行第二步证明。 给定$X_i, X_j \\in P$, 令$Coll_{i,j}$为$X_i, X_j$中内部存在碰撞或者$X_i,X_j$之间存在碰撞，则 $Coll =\\lor_{i, j} \\text { Coll }_{i, j}$, $\\operatorname{Pr}[\\mathrm{Coll}] \\leq \\sum_{i, j : i&lt;j} \\operatorname{Pr}\\left[\\mathrm{Coll}_{i, j}\\right]=\\left(\\begin{array}{c}{q} \\ {2}\\end{array}\\right) \\cdot \\operatorname{Pr}\\left[\\mathrm{Coll}_{i, j}\\right] \\leq \\frac{q^{2}}{2} \\cdot \\operatorname{Pr}\\left[\\mathrm{Coll}_{i, j}\\right]$. 令$X=X_i, X’=X_j$, 两者的块长度都是$l$. $X=(x_1,…,x_l), X’=(x’_1,…,x’_l)$, $t$是最大的整数使得 $(x_1,…,x_t)=(x’_1,…,x’_t)$.（其中 $t &lt; l$ 否则 $X=X’$） 注意到此时$(I_1,…,I_t) = (I’_1,…,I’_t)$. 用下面 $2l-t-2$ 步来确定 $g$ 的值： $i$ 从1到 $t-1$ : ​ 随机均匀选择$g(I_i)$的值从而确定 $I_{i+1}$和$I’_{i+1}$.（注意这步两者相等） $i = t$ : ​ 随机均匀选择$g(I_t)$的值从而确定 $I_{t+1}$和$I’_{t+1}$.（注意这步两者不等） $i$ 从 $t+1$ 到 $l-1$: ​ 随机均匀选择 $g(I_{t+1}),g(I_{t+2}),…,g(I_{l-1})$ 的值从而确定 $I_{t+2}, I_{t+3},…,I_{l}$. $i$ 从 $l$ 到 $2l-t-2$: ​ 随机均匀选择 $g(I’_{t+1}),g(I’_{t+2}),…,g(I’_{l-1})$ 的值从而确定 $I’_{t+2}, I’_{t+3},…,I’_{l}$. 假设事件$Coll(k)$表示第$k$步发生了非平凡碰撞，那么 $\\operatorname{Pr}\\left[\\mathrm{Coll}_{i, j}\\right]=\\operatorname{Pr}\\left[\\lor_{k} \\operatorname{Coll}(k)\\right] \\leq \\operatorname{Pr}[\\operatorname{Coll}(1)]+\\sum_{k=2}^{2l-t-2} \\operatorname{Pr}[\\operatorname{Coll}(k) | \\overline{\\operatorname{Coll}(k-1)}]$. 若 $k&lt;t$, $Coll(k-1)$未发生，则$(I_1,..,I_k)$各不相同，$I_{k+1}=g(I_k) \\oplus x_{k+1}$与前$k$个值发生碰撞的概率为$\\frac{k}{2^n}$, 所以$\\operatorname{Pr}[\\operatorname{Coll}(k) | \\overline{\\operatorname{Coll}(k-1)}]=k / 2^{n}$. 若 $k=t$, $\\operatorname{Pr}[\\operatorname{Coll}(k) | \\overline{\\operatorname{Coll}(k-1)}] \\leq 2t / 2^{n}$, 因为这一步生成了两个值$I_{t+1}, I’_{t+1}$且不相同。 若 $k &gt; t$, $\\operatorname{Pr}[\\operatorname{Coll}(k) | \\overline{\\operatorname{Coll}(k-1)}] \\leq (k+1) / 2^{n}$, 因为第$t$步多生成了一个值，所以加上1. 我们得出 $\\operatorname{Pr}\\left[\\mathrm{Coll}_{i, j}\\right] \\leq 2^{-n} \\cdot\\left(\\sum_{k=1}^{t-1} k+2 t+\\sum_{k=t+1}^{2l-t-2}(k+1)\\right) $ $= 2^{-n} \\cdot \\sum_{k=2}^{2l-t-1} k=2^{-n} \\cdot(2 l - t+1) \\cdot(2l - t-2)/2 &lt; 2 \\ell^{2} \\cdot 2^{-n}$. 所以，我们有 $Pr[Coll] \\leq \\frac{q^2}{2}Pr[Coll_{i,j}] &lt; q^2l^2 \\cdot 2^{-n} = \\delta$. 综合所有，我们有 $Pr[\\forall i: CBC_g(X_i)=t_i] \\geq Pr[\\forall i: CBC_g(X_i)=t_i|\\overline{Coll}] \\cdot Pr[\\overline{Coll}] \\geq 2^{-nq}\\cdot Pr[\\overline{Coll}] \\geq (1-\\delta)\\cdot2^{-nq}$. 这就证明了 $CBC_g$ 是$(q,l,\\delta)-smooth$的。 4. 认证加密如何设计加密方案使其既保证安全性又保证消息的完整性？ 4.1. 定义我们规定密文必须满足某种条件，攻击者无法伪造出有效的密文。 考虑攻击者与挑战者$A$之间不可伪造的加密游戏： 挑战者运行$Gen(1^n)$获得私钥$k$. 攻击者$A$输入$1^n$以及可以用消息$m_i$进行加密查询，挑战者计算$c_i=Enc_k(m_i)$并返回。 攻击者$A$最后输出一段密文$c$. 令$Q$表示攻击者进行的加密查询集合，挑战者计算$m=Dec_k(c)$, 若密文无效输出$\\perp$.攻击者在该游戏中成功当且仅当$m \\neq \\perp$且$m \\notin Q$. 把上述攻击者成功的事件记为事件$S$. 定义4.1: 我们称一个对称加密方案 $\\Pi$ 是不可伪造的，如果对于任意的概率多项式时间攻击者，存在一个可忽略的函数 $negl$ 使得$Pr[S] \\leq negl(n)$. 定义4.2: 如果一个加密方案是CCA安全并且不可伪造的，那么称该方案是一个认证加密。 4.2. 通用构造假设$\\Pi_E=(Enc,Dec)$为CPA安全的加密方案，$\\Pi_M=(Mac, Vrfy)$ 为MAC方案，$k_E, k_M$为对应方案的密钥。考虑下面三种方案： 加密并认证：密文为$$, 其中$c \\leftarrow Enc_{k_E}(m), t \\leftarrow Mac_{k_M}(m)$. 接收者先解密得到$m$, 再验证$Vrfy(m,t)=1$是否成立，若成立，输出$m$, 反之输出错误。 先认证，再加密：密文为$c$, 先计算$t \\leftarrow Mac_{k_M}(m)$, 再计算$c \\leftarrow Enc_{k_E}(m||t)$. 接收者先解密得到$m||t$, 再验证$Vrfy(m,t)=1$是否成立，若成立，输出$m$, 反之输出错误。 先加密，再认证：密文为$$, 先计算$c \\leftarrow Enc_{k_E}(m)$, 再计算$t \\leftarrow Mac_{k_M}(c)$, 接收者先验证$Vrfy(c,t)=1$是否成立，若成立解密出$m$, 反之输出错误。 注意MAC方案不保证不泄露原文的一些消息，所以直接计算明文的MAC值并作为密文的一部分并不安全，方案1，2不适用。 考虑第3种方案，先加密，后认证： Construction 4.3: 假设$\\Pi_E=(Enc,Dec)$为私钥加密方案，$\\Pi_M=(Mac, Vrfy)$ 为消息认证编码。定义如下的私钥加密方案： $Gen’$: 随机均匀选择密钥$k_E, k_M \\in \\{0,1\\}^n$. $Enc’$: 输入消息$m$以及密钥$k_E, k_M$, 计算$c \\leftarrow Enc_{k_E}(m)$, 再计算$t \\leftarrow Mac_{k_M}(c)$, 输出密文$$. $Dec’$: 输入密文$$, 密钥$k_E, k_M$, 首先验证$Vrfy(c, t)=1$是否成立，若成立，输出$m=Dec_{k_E}(c)$, 反之输出$\\perp$. Theorem 4.4: 假设$\\Pi_E$为CPA安全的私钥加密方案，$\\Pi_M$是安全的消息认证编码，则上述构造为一个认证加密方案。 Proof of Theorem 4.4: 非形式化地说，由于密文包含 $c$ 的MAC值，而由于我们假设$\\Pi_M$是不可伪造的MAC方案，所以攻击者无法伪造出$c$的MAC值，也就是说无法伪造出有效的密文。这就说明了该方案是不可伪造的方案。并且由于密文不可伪造性，攻击者进行解密查询的密文都是无效的（有可忽略的概率可能有效），解密预言返回$\\perp$, 所以解密预言并没有给攻击者额外的帮助，所以若 $\\Pi_E$ 是CPA安全的话，该方案是CCA安全的。 假设$A$是概率多项式时间的攻击者在CCA-Game中攻击构造4.3. 称密文$$是新的如果$A$没从加密预言中获得过$$. 定义事件$ValidQuery$为$A$提交给解密预言的密文是新的且是有效的，$Vrfy(c,t)=1$. Claim 4.5: $Pr[ValidQuery]$是可以忽略的。 Proof of Claim 4.5: 令$q(n)$为攻击者$A$进行解密查询的次数，我们构造新的攻击者$A_M$, 把$A$作为子程序调用，在MAC伪造Game中攻击MAC方案$\\Pi_M$. 攻击者$A_M$: 输入$1^n$, 允许其能进行MAC预言查询$Mac_{k_M}(\\cdot)$. $k_E \\leftarrow \\{0,1\\}^n, i \\in \\{1,2,…,q(n)\\}$. 当$A$用$m$进行加密查询时： (1). $c \\leftarrow Enc_{k_E}(m)$, (2). 用$c$进行MAC预言查询，获得$c \\leftarrow Mac_{k_M}(\\cdot)$. 将$$返回给$A$. (3). 用同样的方式生成挑战密文。 当$A$用$$进行解密查询时，若这恰好是第$i$次查询，$A_M$直接输出$$, 否则： (1). 若$$是之前$A$用$m$加密查询生成的，直接返回$m$. (2). 否则输出$\\perp$. 显然$A_E$是概率多项式时间算法。 直观上看，$A_M$预测$A$第$i$次查询 $$ 是新的且有效的查询。则 $$ 从未被$A_M$查询过，$A_M$ 成功伪造了$c$ 的MAC值$t$. 令事件$S_M$为$A_M$成功伪造了$MAC$值。$A$进行新且有效查询的概率为$Pr[ValidQuery]$, 该查询恰好是第$i$次查询的概率为$Pr[ValidQuery]/q(n)$. 所以$Pr[S_M] = Pr[ValidQuery]/q(n)$. 而我们假设 $\\Pi_M$ 是安全的MAC方案，所以$Pr[S_M]$是可忽略的，而又$q(n)$是多项式，所以$Pr[ValidQuery]$ 也是可忽略的。 下面证构造3.5 $\\Pi’$ 是密文不可伪造的。 假设攻击者 $A’$ 能对方案 $\\Pi’$ 进行密文伪造，$A$将$A’$作为子程序调用，当$A’$成功伪造$$时，$A$ 用 $$进行密文查询。但是我们已经证明$A$进行有效密文查询的概率可忽略，所以$A’$伪造成功的概率也可忽略，所以 $\\Pi’$ 是不可伪造的加密方案。 下面证$\\Pi’$ 是CCA安全的。 令事件 $S$ 为攻击者$A$在CCA游戏中成功击破了方案$\\Pi’$. $Pr[S] = Pr[S \\land ValidQuery]+Pr[S \\land \\overline{ValidQuery}] \\leq Pr[ValidQuery] + Pr[S \\land \\overline{ValidQuery}]$. 已知$Pr[ValidQuery]$可忽略，所以只要证明如下Claim. Claim 4.6: $Pr[S \\land \\overline{ValidQuery}] \\leq \\frac{1}{2}+negl(n)$. Proof of Claim 4.6: 直观上看由于$ValidQuery$事件未发生，所有解密查询都是无效的，解密预言未提供任何额外能力，所以如果$\\Pi_E$是CPA安全的话，$\\Pi’$也是CCA安全的。 我们构造攻击者$A_E$在CPA-Game中攻击方案$\\Pi_E$. 攻击者$A_E$: 输入为$1^n$, 能进行加密查询$Enc_{k_E}(\\cdot)$. $k_M \\leftarrow \\{0,1\\}^n$. 当$A$用消息$m$进行加密查询时， (1). 用$m$进行加密查询$Enc_{k_E}(\\cdot)$, 获得$c \\leftarrow Enc_{k_E}(\\cdot)$. (2). 计算$t \\leftarrow Mac_{k_M}(c)$, 将$$返回给$A$. 当$A$用$$进行解密查询时， (1). 若$$是之前消息$m$加密查询的返回值，直接输出$m$. (2). 反之，输出$\\perp$. $A$提交两段等长明文$m_0, m_1$, (1). $A_E$ 将这两段明文提交给自己的挑战者得到挑战密文$c$. (2). 计算$t \\leftarrow Mac_{k_M}(c)$, 将$$作为$A$的挑战密文. 当$A$输出1个bit后，$A_E$ 输出相同的bit. 显然，$A_E$是概率多项式时间的算法。 当事件$ValidQuery$未发生时，$A$作为$A_E$的子程序与在原始的CCA-Game中完全一致。 令事件$S_E$为$A_E$在CPA-Game中成功。从上述算法中我们可得，$A_E$成功当且仅当$A$成功，所以 $Pr[S_E \\land \\overline{ValidQuery}] = Pr[S \\land \\overline{ValidQuery}]$. 我们得出 $Pr[S_E] \\geq Pr[S_E \\land \\overline{ValidQuery}] = Pr[S \\land \\overline{ValidQuery}]$ 又 $\\Pi_E$ 是CPA安全的，$Pr[S_E] \\leq 1/2 + negl(n)$. 所以$Pr[S \\land \\overline{ValidQuery}] \\leq \\frac{1}{2}+negl(n)$. 所以，$Pr[S] \\leq Pr[ValidQuery] + Pr[S \\land \\overline{ValidQuery}] \\leq 1/2 + negl’(n)$. $\\Pi’ $ 是CCA安全的方案。 综上$\\Pi’$是安全的认证加密方案。 4.3. CCA安全加密可伪造与CCA安全不等价，存在可伪造但还是CCA安全的方案。 认证加密与CCA安全其实也不等价，CCA安全方案与认证加密目的不同，认证加密我们要求的是消息的完整性与安全性，CCA安全不考虑消息的完整性，只考虑能进行解密查询的敌手。在公钥加密体制中，CCA安全方案与认证加密的区别较大。","categories":[{"name":"密码学","slug":"密码学","permalink":"https://doublejun12.github.io/categories/密码学/"}],"tags":[{"name":"消息认证编码","slug":"消息认证编码","permalink":"https://doublejun12.github.io/tags/消息认证编码/"},{"name":"认证加密","slug":"认证加密","permalink":"https://doublejun12.github.io/tags/认证加密/"},{"name":"CCA安全","slug":"CCA安全","permalink":"https://doublejun12.github.io/tags/CCA安全/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-07T16:38:37.555Z","updated":"2020-12-10T17:21:49.385Z","comments":true,"path":"2020/12/08/hello-world/","link":"","permalink":"https://doublejun12.github.io/2020/12/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"计算复杂性","slug":"计算复杂性","permalink":"https://doublejun12.github.io/categories/计算复杂性/"},{"name":"密码学","slug":"密码学","permalink":"https://doublejun12.github.io/categories/密码学/"}],"tags":[{"name":"NP完全定理","slug":"NP完全定理","permalink":"https://doublejun12.github.io/tags/NP完全定理/"},{"name":"不可近似性","slug":"不可近似性","permalink":"https://doublejun12.github.io/tags/不可近似性/"},{"name":"PCP定理","slug":"PCP定理","permalink":"https://doublejun12.github.io/tags/PCP定理/"},{"name":"Parallel Repetition定理","slug":"Parallel-Repetition定理","permalink":"https://doublejun12.github.io/tags/Parallel-Repetition定理/"},{"name":"消息认证编码","slug":"消息认证编码","permalink":"https://doublejun12.github.io/tags/消息认证编码/"},{"name":"认证加密","slug":"认证加密","permalink":"https://doublejun12.github.io/tags/认证加密/"},{"name":"CCA安全","slug":"CCA安全","permalink":"https://doublejun12.github.io/tags/CCA安全/"}]}